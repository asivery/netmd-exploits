import { getDescriptiveDeviceCode, NetMDFactoryInterface, NetMDInterface, patch, PatchPeripheralBase, unpatch } from 'netmd-js';
import { Assembler } from './assembler/assembler';
import { CORE_MACROS } from './assembler/core-macros';
import { Exploit, ExploitConstructor, PatchError } from './exploit';
import { loadSafetyPatches } from './safety';
import { deepCopy, getFromVersionStore } from './utils';

export interface DeviceType {
    versionCode: string;
    hwid: number;
    isHimd: boolean;
}

interface LoadedExploit<T extends Exploit> {
    exploit: T,
    resources: {
        patches: number[],
        allocatedAddresses: number[],
    },
}

interface MemoryRange {
    start: number,
    end: number,
}

const INIT_CONFIG = {
    patchAmount: {
        "R*": 4,
        "S*": 8,
        "H*": 16,
    },
    memoryRanges: {
        "S*": [
            {
                start: 0x02006000,
                end: 0x02008FF0,
            }
        ],
        "R*": [
            {
                start: 0x02000e5e,
                end: 0x02000fa0,
            },
            {
                start: 0x0300c900,
                end: 0x300cd00,
            }
        ],
        "H*": [
            {
                start: 0x0080a020,
                end: 0x0080a8d0,
            }
        ]
    },
};

export class AllocationError extends Error {
    constructor(m: string) {
        super(m);
        Object.setPrototypeOf(this, AllocationError.prototype);
    }
}

export class UnloadError extends Error {
    constructor(m: string) {
        super(m);
        Object.setPrototypeOf(this, AllocationError.prototype);
    }
}

export interface Logger{
    log(tag: string, text: string): void;
}

export const ConsoleLogger: Logger = {
    log: (tag: string, text: string) => console.log(`[${tag}]: ${text}`),
};

export class ExploitStateManager {
    loadedList: { [key: string]: LoadedExploit<Exploit> } = {};

    private freePatches: number[];
    private freeMemory: MemoryRange[];
    private usedMemory: {[start: number]: number} = {};
    
    protected constructor(
        public iface: NetMDInterface,
        public factoryIface: NetMDFactoryInterface,
        public device: DeviceType,
        public armAssembler: Assembler,
        public thumbAssembler: Assembler,
        public logger?: Logger,
    ) {
        this.freePatches = Array(this.getMaxPatchesAmount()).fill(0).map((_, i) => i);
        this.freeMemory = deepCopy(getFromVersionStore(INIT_CONFIG, this.device.versionCode, "memoryRanges"));
    }

    public getFreeMemoryMap(){
        return `|${this.freeMemory.map(e => `${e.end - e.start}`).join('|')}|=${this.freeMemory.map(e => e.end - e.start).reduce((a, b) => a + b, 0)}`;
    }

    public getCurrentlyLoaded(){
        return Object.values(this.loadedList).map(e => e.exploit.constructor) as ExploitConstructor<any>[];
    }

    public allocate(length: number){
        length = Math.ceil(length / 4) * 4; // Basic allocation size = 4 bytes
        for(let i = 0; i<this.freeMemory.length; i++){
            let range = this.freeMemory[i];

            if(range.end - range.start >= length){
                let out = range.start;
                range.start += length;
                if(range.end === range.start){
                    this.freeMemory.splice(i, 1);
                }
                this.usedMemory[out] = range.start;
                this.log(`Allocated ${length} bytes of RAM at ${out.toString(16)}`);
                return out;
            }
        }
        throw new AllocationError(`Cannot allocate ${length} bytes of continous memory - free regions are: ${this.getFreeMemoryMap()}`);
    }

    public release(start: number){
        if(this.usedMemory[start] === undefined){
            throw new AllocationError("Cannot release the memory which was never allocated!");
        }
        const rangeFreed = {
            start,
            end: this.usedMemory[start],
        };
        this.log(`Releasing ${rangeFreed.end - rangeFreed.start} bytes of RAM at ${rangeFreed.start.toString(16)}`);
        delete this.usedMemory[start];
        let i = 0;
        for(i; i<this.freeMemory.length; i++){
            if(this.freeMemory[i].start >= rangeFreed.end){
                break;
            }
        }
        this.freeMemory.splice(i, 0, rangeFreed);
        this.mergeMemoryMap();
    }

    private mergeMemoryMap(){
        for(let i = 0; i<this.freeMemory.length - 1; i++){
            if(this.freeMemory[i].end === this.freeMemory[i+1].start){
                this.freeMemory[i].end = this.freeMemory.splice(i+1, 1)[0].end;
                --i;
            }
        }
    }

    public getIncrementalPatchNumber() {
        let thisPatch = this.freePatches.pop();
        if (thisPatch === undefined) {
            throw new PatchError(`Tried exceeding max. patches amount (${this.getMaxPatchesAmount()}). Patch memory full.`);
        }
        return thisPatch;
    }

    public markPatchAsPermanent(patchNumber: number){
        if(patchNumber < 0 || patchNumber >= this.getMaxPatchesAmount()){
            throw new PatchError(`Patch ${patchNumber} is not a valid patch`);
        }
        let index = this.freePatches.indexOf(patchNumber);
        if(index === -1){
            throw new PatchError(`Patch ${patchNumber} has already been distributed to an exploit`);
        }
        this.freePatches.splice(index, 1);
    }

    public freePatch(patch: number){
        if(patch >= this.getMaxPatchesAmount()){
            throw new PatchError("Illegal patch index");
        }
        if(this.freePatches.includes(patch)){
            throw new PatchError("Patch already free");
        }
        this.freePatches.push(patch);
    }

    public getMaxPatchesAmount() {
        return getFromVersionStore(INIT_CONFIG, this.device.versionCode, "patchAmount");
    }

    public async require<T extends Exploit>(subclassConstructor: ExploitConstructor<T>, ...args: Parameters<T["init"]>): Promise<T> {
        if (subclassConstructor._name in this.loadedList) {
            return this.loadedList[subclassConstructor._name].exploit as T;
        } else {
            const overwrittenMethods: {[key: string]: any} = {
                getIncrementalPatchNumber: () => {
                    const thisPatch = this.getIncrementalPatchNumber();
                    loadedEntry.resources.patches.push(thisPatch);
                    this._log(subclassConstructor._name, [`Reserved patch ${thisPatch}`]);
                    return thisPatch;
                },
                freePatch: (patch: number) => {
                    if(!loadedEntry.resources.patches.includes(patch)){
                        throw new PatchError(`Patch ${patch} is not used by this exploit`);
                    }
                    this._log(subclassConstructor._name, [`Released patch ${patch}`]);
                    loadedEntry.resources.patches.splice(loadedEntry.resources.patches.indexOf(patch), 1);
                    this.freePatch(patch);
                },
                allocate: (length: number) => {
                    let allocated = this.allocate(length);
                    loadedEntry.resources.allocatedAddresses.push(allocated);
                    return allocated;
                },
                release: (address: number) => {
                    let localIndex = loadedEntry.resources.allocatedAddresses.indexOf(address);
                    if(localIndex === -1){
                        throw new AllocationError("Cannot release a section of memory not allocated by this exploit");
                    }
                    loadedEntry.resources.allocatedAddresses.splice(localIndex, 1);
                    this.release(address);
                },
                log: (...e: string[]) => {
                    this._log(subclassConstructor._name, e);
                },
                require: (subclassConstructor: ExploitConstructor<T>, ...args: Parameters<T["init"]>) => {
                    return this.require(subclassConstructor, ...args);
                },
                unload: (object: ExploitConstructor<T> | T) => this.unload(object),
            };
            const fake = new Proxy(this, {
                get: (target: any, prop: string, receiver) => (overwrittenMethods[prop] ?? (this as any)[prop])
            });
            let loadedEntry: LoadedExploit<T> = {
                exploit: new subclassConstructor(fake),
                resources: {
                    patches: [],
                    allocatedAddresses: [],
                },
            };
            await loadedEntry.exploit.init(...args);
            this.loadedList[subclassConstructor._name] = loadedEntry;
            return loadedEntry.exploit;
        }
    }

    public async unload<T extends Exploit>(object: ExploitConstructor<T> | T){
        let name: string;
        if ('_name' in object){
            name = object._name;
        }else{
            let foundName = Object.entries(this.loadedList).find(([name, entry]) => entry.exploit === object)?.[0];
            if(!foundName) return;
            name = foundName;
        }
        if (name in this.loadedList){
            const loaded = this.loadedList[name];
            if(loaded.exploit._policies?.permanent){
                throw new UnloadError("Cannot unload a permanent patch");
            }

            // Trigger the unload() code of the exploit
            await loaded.exploit.unload();
            
            // Unpatch all the remaining patches
            for(let patch of loaded.resources.patches){
                if(!loaded.exploit._policies?.stateManagerUnpatchLegal)
                    this.log(`Force-unpatching leftover patch #${patch}. Please clean up the patches using unload() instead!`);
                await unpatch(this.factoryIface, patch, this.getMaxPatchesAmount(), this.device.isHimd ? PatchPeripheralBase.HIMD : PatchPeripheralBase.NETMD);
                this.freePatch(patch);
            }

            // Free all the memory taken by the exploit
            loaded.resources.allocatedAddresses.forEach(this.release.bind(this));

            // Remove the exploit from the loaded list
            delete this.loadedList[name];
        }
    }

    public async patch(address: number, value: Uint8Array, slot?: number){
        return patch(
            this.factoryIface,
            address,
            value,
            slot ?? this.getIncrementalPatchNumber(),
            this.getMaxPatchesAmount(),
            this.device.isHimd ? PatchPeripheralBase.HIMD : PatchPeripheralBase.NETMD,
        );
    }

    public async envelop<T extends Exploit>(subclassConstructor: ExploitConstructor<T>, ...allargs: [...Parameters<T["init"]>, ((exploit: T) => Promise<void>)]){
        const action = allargs[allargs.length - 1];
        const args = allargs.slice(0, -1) as Parameters<T["init"]>;

        const wasLoadedExternally = Object.keys(this.loadedList).includes(subclassConstructor._name);
        const exploit = await this.require(subclassConstructor, ...args);
        await action(exploit);
        if(!wasLoadedExternally)
            await this.unload(subclassConstructor);
    }

    public static async create(iface: NetMDInterface, factoryIface: NetMDFactoryInterface, logger?: Logger) {
        const deviceInfo = await factoryIface.getDeviceCode();
        const versionCode = await getDescriptiveDeviceCode(deviceInfo);
        const esm = new ExploitStateManager(
            iface,
            factoryIface,
            {
                hwid: deviceInfo.hwid,
                versionCode,
                isHimd: versionCode.startsWith("H"),
            },
            await Assembler.create(CORE_MACROS, 'ARM'),
            await Assembler.create(CORE_MACROS, 'THUMB'),
            logger,
        );

        await loadSafetyPatches(esm);
        return esm;
    }

    public log(...e: string[]){
        this._log("StateManager", e);
    }

    protected _log(tag: string, e: string[]){
        this.logger?.log(tag, e.join(" "));
    }
}
