import { getDescriptiveDeviceCode, NetMDFactoryInterface, NetMDInterface, unpatch } from 'netmd-js';
import { Assembler } from './assembler/assembler';
import { CORE_MACROS } from './assembler/core-macros';
import { Exploit, ExploitConstructor, PatchError } from './exploit';
import { loadSafetyPatches } from './safety';
import { getFromVersionStore, getFromVersionStoreOrNull } from './utils';

export interface DeviceType {
    versionCode: string;
    hwid: number;
}

interface LoadedExploit<T extends Exploit> {
    exploit: T,
    resources: {
        patches: number[],
        allocatedAddresses: number[],
    },
}

interface MemoryRange {
    start: number,
    end: number,
}

const INIT_CONFIG = {
    memoryRanges: {
        "S*": [
            {
                start: 0x02005490,
                end: 0x02008FF0,
            }
        ],
        "R*": [
            {
                start: 0x02000e5e,
                end: 0x02000fa0,
            },
            {
                start: 0x0300c900,
                end: 0x300cd00,
            }
        ]
    },
};

export class AllocationError extends Error {
    constructor(m: string) {
        super(m);
        Object.setPrototypeOf(this, AllocationError.prototype);
    }
}

export class UnloadError extends Error {
    constructor(m: string) {
        super(m);
        Object.setPrototypeOf(this, AllocationError.prototype);
    }
}

export class ExploitStateManager {
    loadedList: { [key: string]: LoadedExploit<Exploit> } = {};

    private freePatches: number[];
    private freeMemory: MemoryRange[];
    private usedMemory: {[start: number]: number} = {};
    
    protected constructor(
        public iface: NetMDInterface,
        public factoryIface: NetMDFactoryInterface,
        public device: DeviceType,
        public armAssembler: Assembler,
        public thumbAssembler: Assembler
    ) {
        this.freePatches = Array(this.getMaxPatchesAmount()).fill(0).map((_, i) => i);
        this.freeMemory = [...getFromVersionStore(INIT_CONFIG, this.device.versionCode, "memoryRanges")];
    }

    public getFreeMemoryMap(){
        return `|${this.freeMemory.map(e => `${e.end - e.start}`).join('|')}|=${this.freeMemory.map(e => e.end - e.start).reduce((a, b) => a + b, 0)}`;
    }

    public getCurrentlyLoaded(){
        return Object.values(this.loadedList).map(e => e.exploit.constructor) as ExploitConstructor<any>[];
    }

    public allocate(length: number){
        length = Math.ceil(length / 4) * 4; // Basic allocation size = 4 bytes
        for(let i = 0; i<this.freeMemory.length; i++){
            let range = this.freeMemory[i];

            if(range.end - range.start >= length){
                let out = range.start;
                range.start += length;
                if(range.end === range.start){
                    this.freeMemory.splice(i, 1);
                }
                this.usedMemory[out] = range.start;
                console.log(`[DEBUG]: Allocated ${length} bytes of RAM at ${out}`);
                return out;
            }
        }
        throw new AllocationError(`Cannot allocate ${length} bytes of continous memory - free regions are: ${this.getFreeMemoryMap()}`);
    }

    public release(start: number){
        if(this.usedMemory[start] === undefined){
            throw new AllocationError("Cannot release the memory which was never allocated!");
        }
        const rangeFreed = {
            start,
            end: this.usedMemory[start],
        };
        console.log(`[DEBUG]: Releasing ${rangeFreed.end - rangeFreed.start} bytes of RAM at ${rangeFreed.start}`);
        delete this.usedMemory[start];
        let i = 0;
        for(i; i<this.freeMemory.length; i++){
            if(this.freeMemory[i].start >= rangeFreed.end){
                break;
            }
        }
        this.freeMemory.splice(i, 0, rangeFreed);
        this.mergeMemoryMap();
    }

    private mergeMemoryMap(){
        for(let i = 0; i<this.freeMemory.length - 1; i++){
            if(this.freeMemory[i].end === this.freeMemory[i+1].start){
                this.freeMemory[i].end = this.freeMemory.splice(i+1, 1)[0].end;
                --i;
            }
        }
    }

    public getIncrementalPatchNumber() {
        let thisPatch = this.freePatches.pop();
        if (thisPatch === undefined) {
            throw new PatchError(`Tried exceeding max. patches amount (${this.getMaxPatchesAmount()}). Patch memory full.`);
        }
        return thisPatch;
    }

    public markPatchAsPermanent(patchNumber: number){
        if(patchNumber < 0 || patchNumber >= this.getMaxPatchesAmount()){
            throw new PatchError(`Patch ${patchNumber} is not a valid patch`);
        }
        let index = this.freePatches.indexOf(patchNumber);
        if(index === -1){
            throw new PatchError(`Patch ${patchNumber} has already been distributed to an exploit`);
        }
        this.freePatches.splice(index, 1);
    }

    public freePatch(patch: number){
        if(patch >= this.getMaxPatchesAmount()){
            throw new PatchError("Illegal patch index");
        }
        if(this.freePatches.includes(patch)){
            throw new PatchError("Patch already free");
        }
        this.freePatches.push(patch);
    }

    public getMaxPatchesAmount() {
        return this.device.versionCode.startsWith('R') ? 0x4 : 0x8;
    }

    public async require<T extends Exploit>(subclassConstructor: ExploitConstructor<T>, ...args: Parameters<T["init"]>): Promise<T> {
        if (subclassConstructor._name in this.loadedList) {
            return this.loadedList[subclassConstructor._name].exploit as T;
        } else {
            const overwrittenMethods: {[key: string]: any} = {
                getIncrementalPatchNumber: () => {
                    const thisPatch = this.getIncrementalPatchNumber();
                    loadedEntry.resources.patches.push(thisPatch);
                    return thisPatch;
                },
                freePatch: (patch: number) => {
                    if(!loadedEntry.resources.patches.includes(patch)){
                        throw new PatchError(`Patch ${patch} is not used by this exploit`);
                    }
                    loadedEntry.resources.patches.splice(loadedEntry.resources.patches.indexOf(patch), 1);
                    this.freePatch(patch);
                },
                allocate: (length: number) => {
                    let allocated = this.allocate(length);
                    loadedEntry.resources.allocatedAddresses.push(allocated);
                    return allocated;
                },
                release: (address: number) => {
                    let localIndex = loadedEntry.resources.allocatedAddresses.indexOf(address);
                    if(localIndex === -1){
                        throw new AllocationError("Cannot release a section of memory not allocated by this exploit");
                    }
                    loadedEntry.resources.allocatedAddresses.splice(localIndex, 1);
                    this.release(address);
                }
            };
            const fake = new Proxy(this, {
                get: (target: any, prop: string, receiver) => (overwrittenMethods[prop] ?? target[prop])
            });
            let loadedEntry: LoadedExploit<T> = {
                exploit: new subclassConstructor(fake),
                resources: {
                    patches: [],
                    allocatedAddresses: [],
                },
            };
            await loadedEntry.exploit.init(...args);
            this.loadedList[subclassConstructor._name] = loadedEntry;
            return loadedEntry.exploit;
        }
    }

    public async unload<T extends Exploit>(object: ExploitConstructor<T> | T){
        let name: string;
        if ('_name' in object){
            name = object._name;
        }else{
            let foundName = Object.entries(this.loadedList).find(([name, entry]) => entry.exploit === object)?.[0];
            if(!foundName) return;
            name = foundName;
        }
        if (name in this.loadedList){
            const loaded = this.loadedList[name];
            if(loaded.exploit._policies?.permanent){
                throw new UnloadError("Cannot unload a permanent patch ");
            }

            // Trigger the unload() code of the exploit
            await loaded.exploit.unload();
            
            // Unpatch all the remaining patches
            for(let patch of loaded.resources.patches){
                if(!loaded.exploit._policies?.stateManagerUnpatchLegal)
                    console.log(`[StateManager]: Force-unpatching leftover patch #${patch}. Please clean up the patches using unload() instead!`);
                await unpatch(this.factoryIface, patch, this.getMaxPatchesAmount());
                this.freePatch(patch);
            }

            // Free all the memory taken by the exploit
            loaded.resources.allocatedAddresses.forEach(this.release.bind(this));

            // Remove the exploit from the loaded list
            delete this.loadedList[name];
        }
    }

    public async envelop<T extends Exploit>(subclassConstructor: ExploitConstructor<T>, ...allargs: [...Parameters<T["init"]>, ((exploit: T) => Promise<void>)]){
        const action = allargs[allargs.length - 1];
        const args = allargs.slice(0, -1) as Parameters<T["init"]>;

        const wasLoadedExternally = Object.keys(this.loadedList).includes(subclassConstructor._name);
        const exploit = await this.require(subclassConstructor, ...args);
        await action(exploit);
        if(!wasLoadedExternally)
            await this.unload(subclassConstructor);
    }

    public static async create(iface: NetMDInterface, factoryIface?: NetMDFactoryInterface) {
        if (!factoryIface) {
            factoryIface = await iface.factory();
        }
        const deviceInfo = await factoryIface.getDeviceCode();
        const esm = new ExploitStateManager(
            iface,
            factoryIface,
            {
                hwid: deviceInfo.hwid,
                versionCode: await getDescriptiveDeviceCode(deviceInfo),
            },
            await Assembler.create(CORE_MACROS, 'ARM'),
            await Assembler.create(CORE_MACROS, 'THUMB')
        );

        await loadSafetyPatches(esm);
        return esm;
    }
}
