import { PatchPeripheralBase } from "netmd-js";
import { patch, readPatch } from "netmd-js";
import { ExploitStateManager } from "./exploit-state";
import { formatUIntQuery, getFromVersionStoreOrNull } from "./utils";


// This patch fixes a critical bug in the Sony firmware
// This bug causes the unit to block its ability to write
// tracks via NetMD by corrupting a part of the "NetMD" block
// in the EEPROM when the device resets with
// 'DataAbort', 'SupervisorCall' or 'PrefetchAbort'
//
// Author: 森田 (Morita), Sony Corporation

const HANDLE_FAULT_EEPROM_CORRUPTION = {
    address: {
        "S1.000,S1.600,S1.500,S1.400": 0x000000C4,
    },
    data: {
        "S*": formatUIntQuery("dcff ffea"),
    }
};


// These addresses are for hard-patched developer units only
const DEV_ADDRESSES = [ 0xe6c0, 0xe69c ];


export async function loadSafetyPatches(exploitStateManager: ExploitStateManager){
    if(exploitStateManager.device.versionCode.startsWith("Hx")){
        // MZ-RH1s are mysterious machines
        for(let i = 4; i<exploitStateManager.getMaxPatchesAmount(); i++){
            exploitStateManager.log(`RH1-compat - marked patch ${i} as permanent (high)`);
            exploitStateManager.markPatchAsPermanent(i);
        }
    }
    // Try to locate the patch in the player's patch memory.
    const address = getFromVersionStoreOrNull(HANDLE_FAULT_EEPROM_CORRUPTION, exploitStateManager.device.versionCode, "address");
    const value = getFromVersionStoreOrNull(HANDLE_FAULT_EEPROM_CORRUPTION, exploitStateManager.device.versionCode, "data");
    if(!address){
        exploitStateManager.log(`Cannot lookup HFEC for version ${exploitStateManager.device.versionCode}.`);
        return;
    }
    
    let hfecLoaded = false;

    for(let i = 0; i<exploitStateManager.getMaxPatchesAmount(); i++){
        const patch = await readPatch(exploitStateManager.factoryIface, i);

        if(patch.address === address && patch.data.every((v, i) => v === value[i])){
            exploitStateManager.log(`Found HFEC at patch slot #${i}`);

            exploitStateManager.markPatchAsPermanent(i);
            hfecLoaded = true;
        }
        if(DEV_ADDRESSES.includes(patch.address)){
            exploitStateManager.log(`Found a developer patch at patch slot #${i}`);
            exploitStateManager.markPatchAsPermanent(i);
        }
        
    }
    if(hfecLoaded) return;
    
    exploitStateManager.log(`HFEC couldn't be found on your unit! Soft-patching.`);
    await patch(
        exploitStateManager.factoryIface,
        address,
        value,
        exploitStateManager.getIncrementalPatchNumber(),
        exploitStateManager.getMaxPatchesAmount()
    );
    exploitStateManager.log(`HFEC loaded.`);
}
