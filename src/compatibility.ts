import { Exploit, ExploitConstructor } from './exploit';
import { DeviceType, ExploitStateManager } from './exploit-state';
import { KillEepromWrite } from './exploits/kill-eeprom-writes';
import { PCMFasterUpload } from './exploits/pcm-faster-upload';

import { USBCodeExecution } from './exploits/usb-code-execution';
import {
    CachedSectorControlDownload,
    CachedSectorNoRamControlDownload,
    FirmwareDumper,
    ForceTOCEdit,
    Tetris,
    CachedSectorBulkDownload,
    WaitForDiscToStopSpinning,
    AtracRecovery,
    SPUpload,
    HiMDUnboundedReading,
} from './exploits';
import { isVersionMatchingFormat } from './utils';
import { HiMDUSBClassOverride } from './exploits/himd-usb-class-override';

type AbstractExploitConstructor<T extends Exploit> = (abstract new (statemanager: ExploitStateManager) => T) & { _name: string };

interface VersionSpecific {
    versions: string[],
    exploit: ExploitConstructor<Exploit>
}

const CompatibilityTable: { [key: string]: (string | ExploitConstructor<Exploit> | VersionSpecific)[] } = {
    [FirmwareDumper._name]: ['S*', 'R*', 'Hx*', 'Hr*', 'Hn*'],
    [USBCodeExecution._name]: [
        'S1.600',
        'S1.500',
        'S1.400',
        'S1.300',
        'S1.200',
        'S1.100',
        'S1.000',

        'R1.400',
        'R1.300',
        'R1.200',
        'R1.100',
        'R1.000',

        'Hr1.000',
        'Hn1.100',
        'Hn1.200',
        'Hx1.0A0',
        'Hx1.090',
        'Hx1.070',
    ],
    [CachedSectorControlDownload._name]: [
        'S1.600',
        'S1.500',
        'S1.400',
        'S1.300',
        'S1.200',
        'S1.100',
        'S1.000',

        // Although this method works for Type-R devices, it puts them into an unstable state.
        // 'R1.400',
        // 'R1.300',
        // 'R1.200',
        // 'R1.100',
        // 'R1.000',

        USBCodeExecution,
        WaitForDiscToStopSpinning,
    ],
    [CachedSectorNoRamControlDownload._name]: [
        'S1.600',
        'S1.500',
        'S1.400',
        'S1.300',
        'S1.200',
        'S1.100',
        'S1.000',

        'R1.400',
        'R1.300',
        'R1.200',
        'R1.100',
        'R1.000',

        USBCodeExecution,
        WaitForDiscToStopSpinning,
    ],
    [ForceTOCEdit._name]: [
        'S1.600',
        'S1.500',
        'S1.400',
        'S1.300',
        'S1.200',
        'S1.100',
        'S1.000',

        'R1.400',
        'R1.300',
        'R1.200',
        'R1.100',
        'R1.000',

        USBCodeExecution,
    ],
    [Tetris._name]: [

        'S1.600',
        'S1.500',
        'S1.400',
        'S1.300',
        'S1.200',
        'S1.100',
        'S1.000',

        'HWID 09',
        'HWID 08',
        'HWID 07',
        'HWID 06',
        'HWID 05',
        'HWID 04',

        USBCodeExecution,

    ],
    [KillEepromWrite._name]: [
        'S1.000',
        'S1.100',
        'S1.200',
        'S1.300',
        'S1.400',
        'S1.500',
        'S1.600',

        'R1.000',
        'R1.100',
        'R1.200',
        'R1.300',
        'R1.400',

        USBCodeExecution,
    ],
    [CachedSectorBulkDownload._name]: [
        'Hr1.000',
        'Hn1.100',
        'Hn1.200',

        'S1.600',
        'S1.500',
        'S1.400',
        'S1.300',
        'S1.200',
        'S1.100',
        'S1.000',

        USBCodeExecution,
        WaitForDiscToStopSpinning,
        {
            exploit: HiMDUnboundedReading,
            versions: ['Hn*', 'Hr*'],
        },
    ],
    [PCMFasterUpload._name]: [
        'S1.600',
        'S1.500',
        'S1.400',
        'S1.300',
        'S1.200',
        'S1.100',
        'S1.000',

        'HWID 09',
        'HWID 08',
        'HWID 05',
        'HWID 04'
    ],
    [WaitForDiscToStopSpinning._name]: [
        'S1.600',
        'S1.500',
        'S1.400',
        'S1.300',
        'S1.200',
        'S1.100',
        'S1.000',

        'R*', // It just waits for 10 seconds on type-R devices.
        'Hr*', 'Hn*', // Same with himd (for now)
    ],
    [HiMDUSBClassOverride._name]: [
        'Hr1.000',
        'Hn1.100',
        'Hn1.200',
        'Hx1.070',
        'Hx1.090',
        'Hx1.0A0',
        {
            exploit: HiMDUnboundedReading,
            versions: ['Hr1.000', 'Hn1.100', 'Hn1.200'],
        },
        {
            exploit: USBCodeExecution,
            versions: ['Hx*'],
        },
    ],
    [HiMDUnboundedReading._name]: [
        'Hr1.000',
        'Hn1.100',
        'Hn1.200',
    ],
    [SPUpload._name]: ['S1.600', 'S1.500', 'S1.400', 'S1.300', 'S1.200', 'S1.100', 'S1.000'],
};

const BestSuitedTable: { [key: string]: ExploitConstructor<Exploit>[] } = {
    [AtracRecovery._name]: [CachedSectorBulkDownload, CachedSectorControlDownload, CachedSectorNoRamControlDownload],
};

export function isCompatible<T extends Exploit>(exploit: ExploitConstructor<T> | AbstractExploitConstructor<T>, deviceType: DeviceType) {
    if (Object.keys(BestSuitedTable).includes(exploit._name)) {
        return getBestSuited(exploit, deviceType) !== null;
    }
    let compatibles = CompatibilityTable[exploit._name];
    if (!compatibles)
        throw new Error(`Cannot check compatibility of ${exploit._name} as it hasn't been included in the compatibility table`);
    let dependencies = compatibles.filter((n) => (n as any)._name !== undefined);
    // All dependencies have to be compatible.
    if (!dependencies.every((n) => isCompatible(n as any, deviceType))) {
        return false;
    }

    // All version-dependent dependencies also have to be compatible
    const versionDependent: VersionSpecific[] = compatibles.filter(e =>
        Array.isArray((e as VersionSpecific).versions) &&
        typeof (e as VersionSpecific).exploit === 'function'
    ) as VersionSpecific[];
    const versionDependentForThisVersion = versionDependent.filter(e => e.versions.some(v => isVersionMatchingFormat(v, deviceType.versionCode)));
    if (!versionDependentForThisVersion.every(e => isCompatible(e.exploit, deviceType))) {
        return false;
    }

    const compatibleVersions = CompatibilityTable[exploit._name].filter((n) => typeof n === 'string' && !n.startsWith('HWID ')) as string[];
    const compatibleHWIDs = CompatibilityTable[exploit._name]
        .filter((n) => typeof n === 'string' && n.startsWith('HWID '))
        .map((n) => parseInt((n as string).substring(5), 16));

    return (compatibleHWIDs.length === 0 || compatibleHWIDs.some((e) => e === deviceType.hwid)) &&
        compatibleVersions.some((e) => isVersionMatchingFormat(e, deviceType.versionCode));
}

export function getBestSuited<T extends Exploit>(
    exploitFamily: AbstractExploitConstructor<T>,
    deviceType: DeviceType
): ExploitConstructor<T> | null {
    if (!Object.keys(BestSuitedTable).includes(exploitFamily._name)) {
        return null;
    }
    for (let exploitConstructor of BestSuitedTable[exploitFamily._name]) {
        if (isCompatible(exploitConstructor, deviceType)) {
            return exploitConstructor as ExploitConstructor<T>;
        }
    }
    return null;
}
