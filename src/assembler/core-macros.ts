import { VersionPropertyStore } from '../exploit';
import { getFromVersionStore } from '../utils';
import { Macro } from './assembler';

export const CORE_MACROS: { [key: string]: Macro } = {
    blxar: {
        code: `
            add %macro_argument_0, pc, #0xc
            mov lr, %macro_argument_0
            ldr %macro_argument_0, [ pc ]
            bx %macro_argument_0
            .word %macro_argument_1
        `,
        properties: {},
    },
    blxa: {
        code: `
            @blxar r7, %macro_argument_0
        `,
        properties: {},
    },
    bxar: {
        code: `
            ldr %macro_argument_0, [ pc ]
            bx %macro_argument_0
            .word %macro_argument_1
        `,
        properties: {},
    },
    bxa: {
        code: `
            @bxar r7, %macro_argument_0
        `,
        properties: {},
    },
    bridge: {
        code: (versionProps: VersionPropertyStore, versionCode: string, variablesPassed: { [key: string]: string }, ...args: string[]) => {
            const [type, ...props] = args;
            if (!['word', 'hword', 'byte', 'ascii'].includes(type)) throw new Error(`Unsupported type given: ${type}`);
            let data = '';
            for (let prop of props) {
                let value = getFromVersionStore(versionProps, versionCode, prop);
                if (typeof value === 'string') {
                    value = `"${value.replace('"', '\\"')}"`;
                }
                data += `${prop}: .${type} ${value}\n`;
            }
            return data;
        },
        properties: {},
    },
    fw_compat_bridge: {
        code: ``,
        properties: {
            device_capabilities_address: {
                'Hn1.200': 0x00803938,
            },
            patch_code_base: {
                'S1.600': 0x02002ba0,
                'S1.500': 0x02002b88,
                'S1.400': 0x02002b6c,
                'S1.300': 0x02002a58,
                'S1.200': 0x02002a44,
                'S1.100': 0x02002a3c,
                'S1.000': 0x02002bc4,
            },
            tron_ter_task: {
                //tron_ter_tsk
                'S1.600': 0x0007c5c1,
                'S1.500': 0x0007bb41,
                'S1.400': 0x0007b481,
                'S1.300': 0x00077c19,
                'S1.200': 0x00076449,
                'S1.100': 0x00075a3d,
                'S1.000': 0x0007c731,
            },
            tron_set_flg: {
                'S1.600': 0x0007c095,
                'S1.500': 0x0007b615,
                'S1.400': 0x0007af55,
                'S1.300': 0x000776ed,
                'S1.200': 0x00075f1d,
                'S1.100': 0x00075511,
                'S1.000': 0x0007c205,

                'R1.000': 0x0005c271,
                'R1.100': 0x0005cb59,
                'R1.200': 0x0005d8f1,
                'R1.300': 0x0005dc45,
                'R1.400': 0x0005dce5,
            },
            tron_clr_flg: {
                'S1.600': 0x0007c2c5,
                'S1.500': 0x0007b845,
                'S1.400': 0x0007b185,
                'S1.300': 0x0007791d,
                'S1.200': 0x0007614d,
                'S1.100': 0x00075741,
                'S1.000': 0x0007c435,

                'R1.000': 0x0005c3dd,
                'R1.100': 0x0005ccc5,
                'R1.200': 0x0005da5d,
                'R1.300': 0x0005ddb1,
                'R1.400': 0x0005de51,
            },
            tron_twai_flg: {
                'S1.600': 0x0007c319,
                'S1.500': 0x0007b899,
                'S1.200': 0x000761a1,
                'S1.100': 0x00075795,
                'S1.000': 0x0007c489,
                'S1.400': 0x0007b1d9,
                'S1.300': 0x00077971,

                'R1.000': 0x0005bfa1,
                'R1.100': 0x0005c889,
                'R1.200': 0x0005d621,
                'R1.300': 0x0005d975,
                'R1.400': 0x0005da15,
            },
            usb_do_response: {
                //usbDoResponse
                'S1.600': 0x00077a3d,
                'S1.500': 0x00077045,
                'S1.400': 0x00076971,
                'S1.300': 0x000732c1,
                'S1.200': 0x00071ca9,
                'S1.100': 0x00071321,
                'S1.000': 0x00077ba5,

                'R1.000': 0x00058e35,
                'R1.100': 0x00059715,
                'R1.200': 0x0005a4bd,
                'R1.300': 0x0005a811,
                'R1.400': 0x0005a8b1,
            },
            read_atrac_dram: {
                'S1.600': 0x000781fd,
                'S1.500': 0x00077805,
                'S1.400': 0x00077131,
                'S1.300': 0x00073a71,
                'S1.200': 0x000723bd,
                'S1.100': 0x00071a35,
                'S1.000': 0x00078365,

                'R1.000': 0x0005d37d, // Slow ones
                'R1.100': 0x0005dc65,
                'R1.200': 0x0005e9fd,
                'R1.300': 0x0005ed51,
                'R1.400': 0x0005edf1,
            },
            g_usb_buff: {
                // These are easy to find in handleUnitInfo
                'S1.600': 0x02001170,
                'S1.500': 0x02001158,
                'S1.400': 0x0200113c,
                'S1.300': 0x0200102c,
                'S1.200': 0x02001018,
                'S1.100': 0x02001014,
                'S1.000': 0x0200117c,

                'R1.000': 0x020040f0,
                'R1.100': 0x02004104,
                'R1.200': 0x02004108,
                'R1.300': 0x0200410c,
                'R1.400': 0x02004110,
            },
            g_DiscStateStruct: {
                'S1.600': 0x020001e8,
                'S1.500': 0x020001e8,
                'S1.400': 0x020001e8,
                'S1.300': 0x020001d8,
                'S1.200': 0x020001cc,
                'S1.100': 0x020001cc,
                'S1.000': 0x020001e8,

                'R1.000': 0x02000b34,
                'R1.100': 0x02000b38,
                'R1.200': 0x02000b34,
                'R1.300': 0x02000b34,
                'R1.400': 0x02000b38,
            },
            g_disc_spin_state: {
                'S1.600': 0x02000310,
                'S1.500': 0x02000310,
                'S1.400': 0x02000310,
                'S1.300': 0x020002f8,
                'S1.200': 0x020002ec,
                'S1.100': 0x020002ec,
                'S1.000': 0x02000310,
            },
            ChangeIRQmask: {
                'R1.000': 0x0005e8e1,
                'R1.100': 0x0005f1c9,
                'R1.200': 0x0005ff61,
                'R1.300': 0x000602b5,
                'R1.400': 0x00060355,

                'S1.000': 0x0007f7fd,
                'S1.100': 0x0007861d,
                'S1.200': 0x00079029,
                'S1.300': 0x0007ac61,
                'S1.400': 0x0007e529,
                'S1.500': 0x0007ebe9,
                'S1.600': 0x0007f669,
            }
        },
    },
    patch: {
        code: `
            ; r5:uint8_t  <- patch number
            ; r3:uint32_t <- address
            ; r4:uint32_t <- value
            
            ; Write 5, 12 to main control
            ldr r0, _patch_macro_control
            mov r1, #5
            strb r1, [ r0 ]
            mov r1, #12
            strb r1, [ r0 ]
            
            ldr r0, _patch_macro_base
            lsl r5, r5, #4
            add r0, r0, r5
            
            ; AND 0xFE with patch control
            ldr r1, [ r0 ]
            and r1, r1, #0xFE
            str r1, [ r0 ]
            
            ; AND 0xFD with patch control
            ldr r1, [ r0 ]
            and r1, r1, #0xFD
            str r1, [ r0 ], #4
            
            ; Write patch address
            str r3, [ r0 ], #4
            
            ; Write patch value
            str r4, [ r0 ]
            
            sub r0, r0, #8
            ldr r1, [ r0 ]
            orr r1, r1, #1
            str r1, [ r0 ]
            
            ; Write 5, 9 to main control
            ldr r0, _patch_macro_control
            mov r1, #5
            strb r1, [ r0 ]
            mov r1, #9
            strb r1, [ r0 ]
        
            bx lr

            _patch_macro_control: .word $_patchMacroControl
            _patch_macro_base: .word $_patchMacroBase
        `,
        properties: {
            _patchMacroBase: {
                'R*,S*': 0x03802000,
                'Hr*,Hn*': 0x03804000,
            },
            _patchMacroControl: {
                'R*':  0x03802040,
                'S*':  0x03802080,
                'Hr*,Hn*': 0x03804100,
            },
        },
    },
    unpatch: {
        code: `
            ; r2:uint8_t  <- patch number

            ; Write 5, 12 to main control
            ldr r0, _patch_macro_control
            mov r1, #5
            strb r1, [ r0 ]
            mov r1, #12
            strb r1, [ r0 ]
            
            ldr r0, _patch_macro_base
            add r0, r0, r2, lsl #4

            ; AND 0xFE with patch control
            ldr r1, [ r0 ]
            and r1, r1, #0xFE
            str r1, [ r0 ]

            ; Write 5, 9 to main control
            ldr r0, _patch_macro_control
            mov r1, #5
            strb r1, [ r0 ]
            mov r1, #9
            strb r1, [ r0 ]
        
            bx lr

            _patch_macro_control: .word $_patchMacroControl
            _patch_macro_base: .word $_patchMacroBase
        `,
        properties: {
            _patchMacroBase: {
                'R*,S*': 0x03802000,
                'Hr*,Hn*': 0x03804000,
            },
            _patchMacroControl: {
                'R*': 0x03802040,
                'S*': 0x03802080,
                'Hr*,Hn*': 0x03804100,
            },
        },
    },
    autogen_cleanup: {
        code: (versionProps: VersionPropertyStore, versionCode: string, variablesPassed: { [key: string]: string }, ...args: string[]) => {
            const prologue = `
                push { r3, r4, r5, r6, r7, lr }
            `;
            const epilogue = `
                pop { r3, r4, r5, r6, r7, lr }
                bx lr

                _unpatch:
                    @unpatch
            `;

            return  prologue +
                    args.map(e => `
                        mov r2, #${e}
                        bl _unpatch
                    `).join("\n") +
                    epilogue;
        },
        properties: {},
    },
    ins: {
        code: (versionProps: VersionPropertyStore, versionCode: string, variablesPassed: { [key: string]: string }, ...args: string[]) => {
            if(args.length !== 1){
                throw new Error("Expected 1 argument (property name)")
            }
            return getFromVersionStore(versionProps, versionCode, args[0]);
        },
        properties: {},
    },
    smv: {
        code: (versionProps: VersionPropertyStore, versionCode: string, variablesPassed: { [key: string]: string }, ...args: string[]) => {
            // Safe move (Immediate only!) (Non-THUMB only!)
            // Syntax:
            // @smv r0, #257

            // Caveat: shifting numbers while carrying to the beginning / end is not supported.
            // The number 0xf000000f will be encoded using the mov-lsl-orr method, and not the
            // Correct, `mov` method.
            let r = args[0].toLowerCase(),
                immediate = args[1].toLowerCase();

            if(immediate.startsWith("#")) immediate = immediate.substring(1);
            let immediateNumber;
            if(immediate.startsWith("0x"))
                immediateNumber = parseInt(immediate.substring(2), 16);
            else if(immediate.startsWith("0b"))
                immediateNumber = parseInt(immediate.substring(2), 2);
            else if(immediate.startsWith("0o"))
                immediateNumber = parseInt(immediate.substring(2), 8);
            else
                immediateNumber = parseInt(immediate);

            // Calculate the number's bit-span and shift count
            let binaryEncoded = immediateNumber.toString(2);
            let shiftCount = 0;
            while(binaryEncoded.charAt(binaryEncoded.length - 1 - shiftCount) === '0'){
                shiftCount++;
            }
            
            
            if(binaryEncoded.length <= 8){
                if(shiftCount % 2 === 0){
                    // Is it an encodable immediate?
                    return `mov ${r}, #${immediateNumber}`;
                }else {
                    // Is the shift count a problem?
                    // Since it *is* less-or-eql to 8 bytes of length
                    // And shiftCount % 2 !== 0, we know it is *not* a non-shifted
                    // number. It is safe to shift it right by 1 bit, write that number
                    // in the `mov`, and follow that by shifting the number left by 1 bit
                    return `
                        mov ${r}, #${immediateNumber >>> 1}
                        lsl ${r}, ${r}, #1
                    `;
                }
            }   
            
            // It is not - create it manually by shifting and OR-ing the bytes together
            let bytes = [
                (immediateNumber >>> 24) & 0xFF,
                (immediateNumber >>> 16) & 0xFF,
                (immediateNumber >>> 8) & 0xFF,
                (immediateNumber >>> 0) & 0xFF,
            ];
            let currentInstructions = "";
            let nextShifts = 0;
            let hasSeenNonZero = false;

            for(let byte of bytes){
                if(byte === 0 && !hasSeenNonZero) continue;
                if(!hasSeenNonZero){
                    currentInstructions += `mov ${r}, #${byte}\n`;
                    nextShifts = 0;
                } else if(byte !== 0) {
                    currentInstructions += `
                        lsl ${r}, ${r}, #${nextShifts}
                        orr ${r}, ${r}, #${byte}
                    `;
                    nextShifts = 0;
                }
                nextShifts += 8;
                hasSeenNonZero = true;
            }
            
            if(nextShifts > 8){
                currentInstructions += `
                    lsl ${r}, ${r}, #${nextShifts - 8}
                `;
            }

            return currentInstructions;
        },
        properties: {},
    },
    pcode: {
        // Patch code trigger
        code: `
            @undef
        `,
        properties: {},
    },
    undef: {
        // Undefined instruction
        code: `
            udf #0
        `,
        properties: {},
    },
};
