import { VersionPropertyStore } from '../exploit';
import { getFromVersionStore } from '../utils';
import { Parser } from 'expr-eval';
import { isBrowser } from 'browser-or-node';
import fs from 'fs';
import { Keystone, MODE_ARM, ARCH_ARM, MODE_THUMB, construct, version } from './keystone-arm';
import { join } from 'path';

function processVersionProps(readableCode: string, versionProps: VersionPropertyStore, versionCode: string){
    Object.keys(versionProps)
    .sort((a, b) => b.length - a.length)
    .filter((n) => readableCode.includes('$' + n))
    .forEach(
        (n) =>
            (readableCode = readableCode.replace(new RegExp(`\\$${n}`, 'g'), () => {
                let i = getFromVersionStore(versionProps, versionCode, n);
                if (typeof i === 'number') {
                    return '0x' + i.toString(16);
                }
                return i;
            }))
    );
    return readableCode;
}

export interface Macro {
    code:
        | string
        | ((
              versionProps: VersionPropertyStore,
              versionCode: string,
              variablesPassed: { [key: string]: string },
              ...args: string[]
          ) => string);
    properties: VersionPropertyStore;
}

export class AssemblerSyntaxError extends Error {
    constructor(message: string) {
        super(message);
        Object.setPrototypeOf(this, AssemblerSyntaxError.prototype);
    }
}

export class Assembler {
    private keystone: Keystone;
    private static wasmURL?: string;
    private static wasmArrayBuffer?: ArrayBuffer;
    public static setWASMArrayBuffer(arrayBuffer: ArrayBuffer){
        Assembler.wasmArrayBuffer = arrayBuffer;
    }
    public static setWASMUrl(newURL: string){
        Assembler.wasmURL = newURL;
    }

    public static async create(macros: { [key: string]: Macro }, mode: 'ARM' | 'THUMB' = 'ARM') {
        let promise;
        if(isBrowser){
            if(Assembler.wasmArrayBuffer){
                promise = Promise.resolve(Assembler.wasmArrayBuffer);
            }else if(Assembler.wasmURL) {
                promise = fetch(Assembler.wasmURL).then(e => e.arrayBuffer());
            }else{
                throw new Error("You are running in a browser! Please provide a url to `assembler.wasm`");
            }
        }else{
            promise = new Promise(res => fs.readFile(join(__dirname, "..", "..", "assembler.wasm"), (err, data) => res(data)));
        }
        await construct(promise);
        return new Assembler(macros, mode);
    }

    public static async version() {
        await construct();
        return await version();
    }

    private constructor(private macros: { [key: string]: Macro }, mode: 'ARM' | 'THUMB' = 'ARM') {
        this.keystone = new Keystone(ARCH_ARM, mode === 'ARM' ? MODE_ARM : MODE_THUMB);
    }

    processCode(
        code: string,
        versionProps: VersionPropertyStore,
        versionCode: string,
        variablesPassed: { [key: string]: string },
        ownMacros: { [key: string]: Macro } = {}
    ) {
        Object.entries(variablesPassed).forEach(([from, to]) => (code = code.replace(new RegExp(`%${from}`, 'g'), to)));

        let lines = code.split('\n');
        let newLines = lines.map((line) => {
            let trimmed = this.removeComments(line);
            let evaluated = trimmed.replace(/\<([^\<])*\>/g, (occurrence: string) => {
                let expression = processVersionProps(
                    occurrence.substring(1, occurrence.length - 1),
                    versionProps,
                    versionCode
                );
                return `${Parser.evaluate(expression)}`;
            });
            if (trimmed !== evaluated){
                trimmed = evaluated;
                line = `\n;Evaluated expressions in line '${line}'\n${trimmed}\n;Evaluated expression line end`;
            }
            if (trimmed.startsWith('@')) {
                // Macro
                let [name, ...args] = trimmed.substring(1).split(' ');
                // Remove commas between macro arguments (if present)
                args = args.map((n) => (n.endsWith(',') ? n.substring(0, n.length - 1) : n));

                let thisMacro = this.macros[name] || ownMacros[name];
                if (!thisMacro) {
                    throw new AssemblerSyntaxError(`The macro: ${name} doesn't exist`);
                }

                // Parent inherits all children's VersionStore props
                for (let [k, v] of Object.entries(thisMacro.properties)) {
                    if (!(k in versionProps)) {
                        versionProps[k] = v;
                    }
                }
                let macroCode = thisMacro.code;
                let processedVariables = {
                    ...variablesPassed,
                };
                if (typeof macroCode === 'function') {
                    line = this.processCode(
                        macroCode(versionProps, versionCode, variablesPassed, ...args).trim(),
                        versionProps,
                        versionCode,
                        processedVariables,
                        ownMacros
                    ).trim();
                } else {
                    // Variables don't get inherited by parent.
                    for (let argIdx in args) {
                        processedVariables[`macro_argument_${argIdx}`] = args[argIdx];
                    }
                    line = this.processCode(macroCode, versionProps, versionCode, processedVariables, ownMacros).trim();
                }

                line = `; Unwound macro ${name} (@${name} ${args.join(', ')})\n${line}\n; Macro ${name} end\n`;
            }
            return line;
        });

        let readableCode = newLines.join('\n');

        readableCode = processVersionProps(readableCode, versionProps, versionCode);

        return readableCode;
    }

    assemble(code: string) {
        const response = this.keystone.asm(code, 0);
        if (response.length === 0 && code.trim().length !== 0) throw new Error('Crashed assembler');
        return response;
    }

    removeComments(code: string) {
        return code
            .split('\n')
            .map((line: string) => {
                let commentStart = line.indexOf(';');
                if (commentStart !== -1) {
                    line = line.substring(0, commentStart);
                }
                return line.trim();
            })
            .join('\n');
    }
}
