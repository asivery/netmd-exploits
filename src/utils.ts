import { formatQuery, MemoryType, NetMDFactoryInterface, writeOfAnyLength } from 'netmd-js';
import { CORE_MACROS } from './assembler/core-macros';
import { CompatibilityError, VersionPropertyStore } from './exploit';
import { ExploitStateManager } from './exploit-state';

export function getFromVersionStoreOrNull(store: VersionPropertyStore, version: string, key: string) {
    let substore = store[key];
    if (!substore) return null;
    /*
        Available formats are:
        - R1.600,
        - R1.600,R1.500
        - R*
        - *
    */
    let globalMatch = null,
        wildcardMatch = null,
        exactMatch = null;
    for (let key of Object.keys(substore)) {
        let splitKeys = key.split(',');
        if (splitKeys.includes(version)) {
            exactMatch = key;
        }
        for (let splitKey of splitKeys) {
            splitKey = splitKey.trim();
            if (splitKey === '*') globalMatch = key;
            else if (isVersionMatchingFormat(splitKey, version)) wildcardMatch = key;
        }
    }
    let matched = exactMatch ?? wildcardMatch ?? globalMatch;
    if (matched === null) {
        return null;
    }
    return substore[matched];
}

export function isVersionMatchingFormat(format: string, version: string) {
    return new RegExp('^' + format.replace(/\*/g, '.*') + '$').test(version);
}

export function getFromVersionStore(store: VersionPropertyStore, version: string, key: string) {
    const value = getFromVersionStoreOrNull(store, version, key);
    if (value === null)
        throw new CompatibilityError(`Cannot get ${key} from version store. The version given (${version}) is incompatible`);
    return value;
}

export function formatUIntQuery(data: string, ...props: any[]): Uint8Array {
    return new Uint8Array(formatQuery(data, props));
}

export function arrayShallowEquals(a: any[], b: any[]) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) return false;
    }
    return true;
}

export function findBytes(haystack: Uint8Array, needle: Uint8Array, offset = 0) {
    while (offset < haystack.length) {
        if (haystack[offset] !== needle[0]) ++offset;
        else {
            let broken = false;
            for (let character of Array.from(needle)) {
                if (character == haystack[offset]) ++offset;
                else {
                    broken = true;
                    break;
                }
                if (offset > haystack.length) return -1; // End of data
            }
            if (!broken) return offset - needle.length;
        }
    }
    return -1;
}

export async function writePatchCodeSection(esm: ExploitStateManager, data: Uint8Array, slot: number) {
    const offset = getFromVersionStoreOrNull(CORE_MACROS.fw_compat_bridge.properties, esm.device.versionCode, 'patch_code_base');
    await writeOfAnyLength(esm.factoryIface, offset + 40 * slot, data, MemoryType.MAPPED);
}

export function  deepCopy<T extends any>(obj: T): T{
    return JSON.parse(JSON.stringify(obj)) as T;
}