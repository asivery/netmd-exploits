import { concatUint8Arrays, createAeaHeader, createWavHeader, sleep } from 'netmd-js/dist/utils';
import { Exploit } from '../../exploit';
import { arrayShallowEquals } from '../../utils';
import { DiscFormat, readUTOCSector } from 'netmd-js';
import { discAddressToLogical, Fragment, getTitleByTrackNumber, ModeFlag, parseTOC } from 'netmd-tocmanip';
import { WaitForDiscToStopSpinning } from '../wait-for-disc-spinning';

interface TimeRepresentation {
    low: number;
    high: number;
    type: number;
}

// I have copied this code from the firmware. The conversion
// of "LP / Mono" time to "SP" time happens on these "TimeRepresentation" objects.
function timeToRepresentation(seconds: number) {
    let unk = Math.floor((seconds * 1566) / 100);
    return {
        low: unk & 0b00011111,
        high: (unk >> 5) & 0xffff,
        type: (unk & 1) == 0 ? 0 : 6,
    };
}

function representationToTime({ low, high }: TimeRepresentation) {
    let unk = (high << 5) | low;
    let seconds = Math.floor((unk * 100) / 1566);
    return seconds;
}

function translateRepresentationToLP4(time: TimeRepresentation) {
    let newHigh = time.high >> 2,
        newLow = (time.high & 3) * 0x20 + (time.low >> 2),
        newType = (time.low & 3) * 0xb + (time.type >> 2);
    if (5 < newType && newLow * 1 == 0) {
        newLow += 1;
    }
    if (0x1f < newLow) {
        newLow -= 0x20;
        newHigh += 1;
    }
    time.high = newHigh;
    time.low = newLow;
    time.type = newType;
}

function translateRepresentationToLP2Mono(time: TimeRepresentation) {
    let newHigh = time.high >> 1,
        newLow = (time.high & 1) * 0x20 + (time.low >> 1),
        newType = ((time.low << 0x1f) >> 0x1f) * -0xb + (time.type >> 1);
    if (5 < newType && (newLow & 1) == 0) {
        newLow += 1;
    }
    if (0x1f < newLow) {
        newLow -= 0x20;
        newHigh += 1;
    }
    time.high = newHigh;
    time.low = newLow;
    time.type = newType;
}

function translateRepresentationFromLP4(time: TimeRepresentation) {
    let newLow, newHigh, newType, tempNewHigh, tempNewLow;

    tempNewLow = 0;
    tempNewHigh = time.high << 2;
    newHigh = tempNewHigh;

    for (newType = time.type * 4; 10 < newType; newType -= 0xb) tempNewLow += 2;
    for (tempNewLow = ((time.low >> 1) << 1) * 4; 0x1f < tempNewLow; tempNewLow -= 0x20) {
        tempNewHigh += 1;
        newHigh = tempNewHigh;
    }
    newLow = tempNewLow;
    if (5 < newType) {
        newLow |= 1;
    }
    time.type = newType;
    time.low = newLow;
    time.high = newHigh;
}

function translateRepresentationFromLP2Mono(time: TimeRepresentation) {
    let newLow, newHigh, newType, tempNewHigh, tempNewLow;

    tempNewLow = 0;
    tempNewHigh = time.high << 1;
    newHigh = tempNewHigh;

    for (newType = time.type * 2; 10 < newType; newType -= 0xb) tempNewLow += 2;
    for (tempNewLow = ((time.low >> 1) << 1) * 2; 0x1f < tempNewLow; tempNewLow -= 0x20) {
        tempNewHigh += 1;
        newHigh = tempNewHigh;
    }
    newLow = tempNewLow;
    if (5 < newType) {
        newLow |= 1;
    }
    time.type = newType;
    time.low = newLow;
    time.high = newHigh;
}

function validSector(sectorContent: Uint8Array){
    for (let frame = 10; frame >= 0; frame--) {
        const frameStartAddress = frame * 212; // 212 - one ATRAC sound frame.
        // TODO: we should consider checking whether or not the Block Size Modes are valid
        // The first two bits are the low band, third and fourth are the mid band,
        // fifth and sixth are the high band, and the final two bits are unused 

        //Byte 0 and Byte 211 are the Block Size Mode
        //Byte 1 and Byte 210 are the number of Block Floating Units
        if (sectorContent[frameStartAddress + 20] !== sectorContent[frameStartAddress + 211 + 20] &&
            sectorContent[frameStartAddress+1 + 20] !== sectorContent[frameStartAddress + 210 + 20]) {
            return false;
        }
    }
    return true;
}

export type AtracRecoveryConfig = {
    writeHeader?: boolean;
    forceRemoveLPBytes?: boolean;
    startSeconds?: number;
    startSectors?: number;
    secondsToRead?: number;
    sectorsToRead?: number;
};

const defaultConfig: AtracRecoveryConfig = {
    writeHeader: true,
    forceRemoveLPBytes: false,
    startSeconds: 0,
    startSectors: -1,
    secondsToRead: -1,
    sectorsToRead: -1,
};

export abstract class AtracRecovery extends Exploit {
    public static _name = 'AtracRecovery';
    protected abstract readNextSector(callback?: (data: {read: number, length: number}) => void): Promise<Uint8Array>;
    protected abstract setSectorToRead(sector: number, sectorsRemaining: number): Promise<void>;

    protected abstract startDownload(track: number): Promise<void>;
    protected abstract finishDownload(): Promise<void>;

    async downloadTrack(
        track: number,
        progressCallback?: (data: { read: number; total: number; action: 'READ' | 'SEEK' | 'CHUNK'; sector?: string }) => void,
        config?: AtracRecoveryConfig
    ){
        let finalData: Uint8Array[] = [];
        for await(let chunk of this.downloadTrackGenerator(track, progressCallback, config)){
            finalData.push(chunk);
        }
        return concatUint8Arrays(...finalData);
    }

    async *downloadTrackGenerator(
        track: number,
        progressCallback?: (data: { read: number; total: number; action: 'READ' | 'SEEK' | 'CHUNK'; sector?: string }) => void,
        config?: AtracRecoveryConfig
    ) {
        // Merge the configs
        if(!config) config = {};
        for(let [k, v] of Object.entries(defaultConfig)){
            if(!(k in config)){
                (config as any)[k] = v;
            }
        }
        const { writeHeader, forceRemoveLPBytes } = config;
        if(config.secondsToRead! > 0){
            config.sectorsToRead = Math.floor(config.secondsToRead! / (704/11025));
        }
        if(config.startSeconds === -1 && config.startSectors !== -1){
            config.startSeconds = Math.floor(config.startSectors! * (704/11025));
        }
        let time = 0, bufferStartTime = 0;

        try {
            // Get info about the track - what format is it and what's the final sector
            const sector0 = await readUTOCSector(this.stateManager.factoryIface, 0);

            const toc = parseTOC(sector0);
            const trackRootFragment = toc.trackFragmentList[toc.trackMap[track + 1]];
            const formatStr =
                ((trackRootFragment.mode & ModeFlag.F_STEREO) !== 0 ? '1' : '0') +
                ((trackRootFragment.mode & ModeFlag.F_SP_MODE) !== 0 ? '1' : '0');

            let format = {
                '00': 'LP4',
                '10': 'LP2',
                '11': 'SPS',
                '01': 'SPM',
            }[formatStr]!;

            let sectorsRead = 0;
            let sectorsToReadAmount = 0,
                allSectors = 0;

            let thisTrackSectorRanges: [number, number][] = [];
            let metadataSectionBlacklist: number[][] = [];
            const rawAddressToLogical = (data: number[]) => (data[0] << 8 | data[1]) * 32 + data[2];
            const addFragment = (fragment: Fragment) => {
                let endSector = discAddressToLogical(fragment.end);
                let startSector = discAddressToLogical(fragment.start);
                allSectors += (endSector - startSector);
                if(fragment.end.group !== 0) allSectors += 1;
                thisTrackSectorRanges.push([startSector, endSector]);
            }
            const isPartOfThisTrack = (logical: number) => thisTrackSectorRanges.some(([start, end]) => logical >= start && logical <= end);
            const fromSectorAddressToString = (raw: number[]) => `${((raw[0] << 8) | raw[1]).toString(16).padStart(4, '0')}.${raw[2].toString(16).padStart(2, '0')}`;

            let lastFragment = trackRootFragment;
            while (lastFragment.link !== 0) {
                addFragment(lastFragment);
                lastFragment = toc.trackFragmentList[lastFragment.link];
            }
            addFragment(lastFragment);

            sectorsToReadAmount = config.sectorsToRead === -1 ? allSectors : Math.min(config.sectorsToRead!, allSectors);

            let absoluteTimeStart = new Date().getTime();

            let wait = async () => await sleep(10000);

            const sleeper = await this.stateManager.require(WaitForDiscToStopSpinning);
            wait = async () => await sleeper.wait();


            if(writeHeader){
                if (format.startsWith('LP')) {
                    yield createWavHeader(
                        format === 'LP2' ? DiscFormat.lp2 : DiscFormat.lp4,
                        sectorsToReadAmount * (2332 - (20 * 11))
                    );
                } else {
                    // We might as well give it the correct name
                    const sector1 = await readUTOCSector(this.stateManager.factoryIface, 1);
                    const nameToc = parseTOC(null,  sector1);
                    const name = getTitleByTrackNumber(nameToc, track + 1);
                    yield createAeaHeader(name, ((trackRootFragment.mode & ModeFlag.F_STEREO) !== 0) ? 2 : 1, sectorsToReadAmount * 11);
                }
            }

            await this.iface.gotoTrack(track);
            await this.iface.gotoTime(track, Math.floor(config.startSeconds! / 3600), Math.floor((config.startSeconds! % 3600) / 60), config.startSeconds! % 60);
            await wait();

            await this.startDownload(track);
            await this.setSectorToRead(0, sectorsToReadAmount);

            if (progressCallback)
                progressCallback({
                    read: sectorsRead,
                    total: sectorsToReadAmount,
                    action: 'SEEK',
                });

            // This is experimental code. It might not work in all cases.
            let sector = 0;

            let sectorPositionsRead: number[] = [];
            let isAfterBlacklist = false;
            let alignmentKnockBack = 0;

            bufferStartTime = new Date().getTime();

            while (sector < 0xfff) {
                if(sectorsRead === sectorsToReadAmount){
                    console.log(`Dumping complete in ${time} / ${new Date().getTime() - absoluteTimeStart} ms!`);
                    await this.finishDownload();
                    return;
                }
                let sectorContent = await this.readNextSector(progressCallback && (data => {
                    progressCallback({
                        read: data.read + sectorsRead,
                        total: sectorsToReadAmount,
                        action: 'CHUNK',
                    });
                }));
                sector++;

                const sectorMetadata = Array.from(sectorContent.slice(0, 20));
                const currentPosition = sectorMetadata.slice(sectorMetadata.length - 8, sectorMetadata.length - 5);
                const currentLogical = rawAddressToLogical(currentPosition);
                // console.log(`Read sector 0x${sector.toString(16)} of DRAM. It contains the disc sector 0x${fromSectorAddressToString(currentPosition)}(0x${currentLogical.toString(16)})`);
                if (
                    !validSector(sectorContent) ||
                    !isPartOfThisTrack(currentLogical) ||
                    sectorPositionsRead.includes(currentLogical)
                ) {
                    if(metadataSectionBlacklist.some(e => arrayShallowEquals(sectorMetadata, e)) ){
                        console.log(`Read sector with metadata block in the blacklist (@${fromSectorAddressToString(currentPosition)}). It will be skipped.`);
                        if (isAfterBlacklist) {
                            sectorsRead++;
                            isAfterBlacklist = false;
                        }
                        continue;
                    }
                    // We're past the ATRAC data and are reading garbage data from the device's DRAM.
                    // Calculate the time offset, move the head using standard netmd commands.
                    // The 704/11025 fraction is a simplified version of (11/2) * (512/44100), which expresses
                    // 11 soundgroups/2 sectors, where each soundgroup contain 512 samples / sample rate of 44100
                    let originalSeconds = sectorsRead * (704/11025) - alignmentKnockBack;
                    if (format !== 'SPS') {
                        // It's not SP Stereo
                        // Use the reverse of the functions used in the gotoTrack handler within the firmware, to convert the "SP" time
                        // SP time   >>   LP time   >>   SP time
                        // \_____/        \______/       \_____/
                        //   \/              \/             \/
                        // local var     time given     time converted
                        //  seconds     to gotoTrack     back within
                        //                               the firmware
                        //                               (@0x00012526 for B1.600)
                        let representation = timeToRepresentation(originalSeconds);
                        switch (format) {
                            case 'SPM':
                            case 'LP2':
                                translateRepresentationFromLP2Mono(representation);
                                break;
                            case 'LP4':
                                translateRepresentationFromLP4(representation);
                                break;
                        }
                        originalSeconds = representationToTime(representation);
                    }
                    let thisBufferTime = (new Date().getTime() - bufferStartTime);
                    console.log(
                        `The sector read is not an ATRAC sector. Sectors read previously add up to ${originalSeconds} seconds. Jumping to that time`
                    );
                    metadataSectionBlacklist.push([...sectorMetadata]);
                    isAfterBlacklist = true;

                    let alignmentTries = 0;
                    let thisAlignmentKnockBack = 0;
                    for (;;) {
                        let seconds = config.startSeconds! + originalSeconds - thisAlignmentKnockBack;
                        let hours = Math.floor(seconds / 3600);
                        seconds -= hours * 3600;
                        let minutes = Math.floor(seconds / 60);
                        seconds -= minutes * 60;

                        console.log(`Jumping to ${hours}:${minutes}:${seconds} (knockback: ${thisAlignmentKnockBack} + ${alignmentKnockBack})`);

                        if (progressCallback)
                            progressCallback({
                                read: sectorsRead,
                                total: sectorsToReadAmount,
                                action: 'SEEK',
                            });

                        await this.finishDownload(); // Switch back to normal commands.
                        await sleep(1000);
                        await this.iface.stop();
                        let tries = 0;
                        while(true){
                            try{
                                await this.iface.gotoTime(track, hours, minutes, seconds);
                                break;
                            }catch(ex){
                                console.log("While jumping");
                                console.log(ex);
                                if(tries++ > 5){
                                    throw new Error("Cannot jump to time!");
                                }
                                await sleep(1000);
                            }
                        }
                        await this.iface.stop();
                        await wait();
                        await this.startDownload(track); // Switch to ATRAC recovery.


                        await this.setSectorToRead(0, 1);

                        let syncSector = await this.readNextSector();
                        let position = Array.from(syncSector.slice(20 - 8, 20 - 5));
                        console.log(`After moving the head, position is ${position.map((n) => n.toString(16).padStart(2, '0')).join('')}`);

                        let alignmentPosition = [...sectorPositionsRead].reverse().indexOf(rawAddressToLogical(position));
                        if(alignmentPosition !== -1) alignmentPosition++;

                        if (alignmentPosition === -1) {
                            // Cannot align.
                            if (alignmentTries < 3) {
                                alignmentTries++;
                                thisAlignmentKnockBack += 2; // Try to align
                                continue;
                            }
                            console.log("DEBUG");
                            console.log("Could not align!");
                            console.log(`originalSeconds=${originalSeconds}`);
                            console.log(`thisAlignmentKnockBack=${thisAlignmentKnockBack}`);
                            console.log(`alignmentKnockBack=${alignmentKnockBack}`);
                            console.log(`syncSector=${Array.from(syncSector).map((n) => n.toString(16).padStart(2, '0')).join('')}`);
                            console.log(`sectorPositionsRead=${sectorPositionsRead.join(', ')}`);
                            console.log("DEBUG END");
                            await this.finishDownload();
                            throw new Error('Cannot align!');
                        }
                        sector = 0;
                        alignmentTries = 0;
                        console.log(`Aligned! Running ${alignmentPosition} sectors behind!`);
                        time += thisBufferTime;
                        bufferStartTime = new Date().getTime();
                        await this.setSectorToRead(alignmentPosition, sectorsToReadAmount - sectorsRead);
                        alignmentKnockBack += thisAlignmentKnockBack;
                        break;
                    }
                } else {
                    // It's a valid ATRAC-containing sector.
                    // Add its position to the list of already done sectors.
                    sectorPositionsRead.push(currentLogical);
                    if (format.startsWith('LP') || forceRemoveLPBytes) {
                        // It's LP - remove the SP compatibility bytes.
                        // There are 12 zero-bytes at the start or each frame
                        // and 8 at the end.
                        const sectorAsArray = Array.from(sectorContent.slice(20));
                        for (let frame = 10; frame >= 0; frame--) {
                            const frameStartAddress = frame * 212; // 212 - one ATRAC sound frame.
                            sectorAsArray.splice(frameStartAddress + 212 - 8, 8);
                            sectorAsArray.splice(frameStartAddress, 12);
                        }
                        yield new Uint8Array(sectorAsArray);
                    } else {
                        yield sectorContent.slice(20);
                    }
                    sectorsRead += 1;
                    // We got a good sector, so this is no longer true
                    isAfterBlacklist = false;
                    if (progressCallback)
                        progressCallback({
                            read: sectorsRead,
                            total: sectorsToReadAmount,
                            action: 'READ',
                            sector: fromSectorAddressToString(currentPosition),
                        });
                }
            }
        } catch (ex) {
            await this.finishDownload(); // If anything goes wrong, at least try to put the device back into a usable state.
            throw ex;
        }
    }
}
