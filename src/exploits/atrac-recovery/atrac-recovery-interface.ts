import { concatUint8Arrays, createAeaHeader, createWavHeader, sleep } from 'netmd-js/dist/utils';
import { Exploit } from '../../exploit';
import { arrayShallowEquals, formatUIntQuery } from '../../utils';
import { DiscFormat, readUTOCSector } from 'netmd-js';
import { discAddressToLogical, Fragment, getTitleByTrackNumber, ModeFlag, parseTOC } from 'netmd-tocmanip';
import { WaitForDiscToStopSpinning } from '../wait-for-disc-spinning';

interface TimeRepresentation {
    low: number;
    high: number;
    type: number;
}

// I have copied this code from the firmware. The conversion
// of "LP / Mono" time to "SP" time happens on these "TimeRepresentation" objects.
function timeToRepresentation(seconds: number) {
    let unk = Math.floor((seconds * 1566) / 100);
    return {
        low: unk & 0b00011111,
        high: (unk >> 5) & 0xffff,
        type: (unk & 1) == 0 ? 0 : 6,
    };
}

function representationToTime({ low, high }: TimeRepresentation) {
    let unk = (high << 5) | low;
    let seconds = Math.floor((unk * 100) / 1566);
    return seconds;
}

function translateRepresentationToLP4(time: TimeRepresentation) {
    let newHigh = time.high >> 2,
        newLow = (time.high & 3) * 0x20 + (time.low >> 2),
        newType = (time.low & 3) * 0xb + (time.type >> 2);
    if (5 < newType && newLow * 1 == 0) {
        newLow += 1;
    }
    if (0x1f < newLow) {
        newLow -= 0x20;
        newHigh += 1;
    }
    time.high = newHigh;
    time.low = newLow;
    time.type = newType;
}

function translateRepresentationToLP2Mono(time: TimeRepresentation) {
    let newHigh = time.high >> 1,
        newLow = (time.high & 1) * 0x20 + (time.low >> 1),
        newType = ((time.low << 0x1f) >> 0x1f) * -0xb + (time.type >> 1);
    if (5 < newType && (newLow & 1) == 0) {
        newLow += 1;
    }
    if (0x1f < newLow) {
        newLow -= 0x20;
        newHigh += 1;
    }
    time.high = newHigh;
    time.low = newLow;
    time.type = newType;
}

function translateRepresentationFromLP4(time: TimeRepresentation) {
    let newLow, newHigh, newType, tempNewHigh, tempNewLow;

    tempNewLow = 0;
    tempNewHigh = time.high << 2;
    newHigh = tempNewHigh;

    for (newType = time.type * 4; 10 < newType; newType -= 0xb) tempNewLow += 2;
    for (tempNewLow = ((time.low >> 1) << 1) * 4; 0x1f < tempNewLow; tempNewLow -= 0x20) {
        tempNewHigh += 1;
        newHigh = tempNewHigh;
    }
    newLow = tempNewLow;
    if (5 < newType) {
        newLow |= 1;
    }
    time.type = newType;
    time.low = newLow;
    time.high = newHigh;
}

function translateRepresentationFromLP2Mono(time: TimeRepresentation) {
    let newLow, newHigh, newType, tempNewHigh, tempNewLow;

    tempNewLow = 0;
    tempNewHigh = time.high << 1;
    newHigh = tempNewHigh;

    for (newType = time.type * 2; 10 < newType; newType -= 0xb) tempNewLow += 2;
    for (tempNewLow = ((time.low >> 1) << 1) * 2; 0x1f < tempNewLow; tempNewLow -= 0x20) {
        tempNewHigh += 1;
        newHigh = tempNewHigh;
    }
    newLow = tempNewLow;
    if (5 < newType) {
        newLow |= 1;
    }
    time.type = newType;
    time.low = newLow;
    time.high = newHigh;
}

function validSector(atracData: Uint8Array) {
    for (let frame = (atracData.length / 212) - 1; frame >= 0; frame--) {
        const frameStartAddress = frame * 212; // 212 - one ATRAC sound frame.
        // TODO: we should consider checking whether or not the Block Size Modes are valid
        // The first two bits are the low band, third and fourth are the mid band,
        // fifth and sixth are the high band, and the final two bits are unused

        //Byte 0 and Byte 211 are the Block Size Mode
        //Byte 1 and Byte 210 are the number of Block Floating Units
        if (
            atracData[frameStartAddress] !== atracData[frameStartAddress + 211] &&
            atracData[frameStartAddress + 1] !== atracData[frameStartAddress + 210]
        ) {
            return false;
        }
    }
    return true;
}

const defaultReturn: <T>(e: T) => (..._: any[]) => T = e => (..._: any[]) => e;

export type AtracRecoveryConfig = {
    writeHeader?: boolean;
    removeLPBytes?: 'always' | 'auto' | 'never';
    startSeconds?: number;
    startSectors?: number;
    secondsToRead?: number;
    sectorsToRead?: number;
    verifyValidAtrac?: boolean;
    includeMetadataSection?: boolean;
    respectSoundgroupsBoundaries?: boolean;
    shouldCancelImmediately?: () => boolean;
    handleBadSector?: (address: string, countThisDRAM: number) => Promise<'reload' | 'abort' | 'skip' | 'yieldanyway'>;
};

const defaultConfig: AtracRecoveryConfig = {
    writeHeader: true,
    removeLPBytes: 'auto',
    startSeconds: 0,
    startSectors: -1,
    secondsToRead: -1,
    sectorsToRead: -1,
    verifyValidAtrac: true,
    includeMetadataSection: false,
    respectSoundgroupsBoundaries: true,
    shouldCancelImmediately: defaultReturn(false),
    handleBadSector: defaultReturn(Promise.resolve('reload')),
};

export abstract class AtracRecovery extends Exploit {
    public static _name = 'AtracRecovery';
    public abstract readNextSector(callback?: (data: { read: number; length: number }) => void): Promise<Uint8Array>;
    public abstract setSectorToRead(sector: number, sectorsRemaining: number): Promise<void>;

    public abstract startDownload(track: number): Promise<void>;
    public abstract finishDownload(): Promise<void>;

    async downloadTrack(
        track: number,
        progressCallback?: (data: { read: number; total: number; action: 'READ' | 'SEEK' | 'CHUNK'; sector?: string }) => void,
        config?: AtracRecoveryConfig
    ) {
        let finalData: Uint8Array[] = [];
        for await (let chunk of this.downloadTrackGenerator(track, progressCallback, config)) {
            if(chunk.chunk && !['callMetadata', 'toc'].includes(chunk.type)){
                finalData.push(chunk.chunk);
            }
        }
        return concatUint8Arrays(...finalData);
    }

    async downloadTrackWithMarkers(
        track: number,
        progressCallback?: (data: { read: number; total: number; action: 'READ' | 'SEEK' | 'CHUNK'; sector?: string }) => void,
        config?: AtracRecoveryConfig
    ){
        let finalData: Uint8Array[] = [];
        const te = new TextEncoder();
        const map: {[chunkType in 'header' | 'audioData' | 'dramSplit' | 'metadata' | 'callMetadata' | 'toc']: Uint8Array} = {
            audioData: te.encode('A'),
            dramSplit: te.encode('D'),
            header: te.encode('H'),
            metadata: te.encode('M'),
            callMetadata: te.encode('C'),
            toc: te.encode('T'),
        };

        finalData.push(te.encode("NEX-RAWSTREAM"));
        
        for await (let chunk of this.downloadTrackGenerator(track, progressCallback, config)) {
            finalData.push(map[chunk.type]);
            finalData.push(formatUIntQuery("%d", chunk.chunk?.length ?? 0));
            if(chunk.chunk){
                finalData.push(chunk.chunk);
            }
        }
        return concatUint8Arrays(...finalData);
    }

    async *downloadTrackGenerator(
        track: number,
        progressCallback?: (data: { read: number; total: number; action: 'READ' | 'SEEK' | 'CHUNK'; sector?: string }) => void,
        config?: AtracRecoveryConfig
    ): AsyncGenerator<{chunk?: Uint8Array, type: 'header' | 'audioData' | 'dramSplit' | 'metadata' | 'callMetadata' | 'toc' }> {
        // Merge the configs
        if (!config) config = {};
        for (let [k, v] of Object.entries(defaultConfig)) {
            if (!(k in config)) {
                (config as any)[k] = v;
            }
        }
        if (config.secondsToRead! > 0) {
            config.sectorsToRead = Math.floor(config.secondsToRead! / (704 / 11025));
        }
        if (config.startSeconds === -1 && config.startSectors !== -1) {
            config.startSeconds = Math.floor(config.startSectors! * (704 / 11025));
        }
        let time = 0,
            bufferStartTime = 0;

        let nextSectorBeginRemove = 0;
        let nextSectorBeginInclude = 0;

        try {
            // Get info about the track - what format is it and what's the final sector
            const sector0 = await readUTOCSector(this.stateManager.factoryIface, 0);

            yield { type: 'toc', chunk: sector0 };

            const toc = parseTOC(sector0);
            const trackRootFragment = toc.trackFragmentList[toc.trackMap[track + 1]];
            const formatStr =
                ((trackRootFragment.mode & ModeFlag.F_STEREO) !== 0 ? '1' : '0') +
                ((trackRootFragment.mode & ModeFlag.F_SP_MODE) !== 0 ? '1' : '0');

            let format = {
                '00': 'LP4',
                '10': 'LP2',
                '11': 'SPS',
                '01': 'SPM',
            }[formatStr]!;

            let sectorsRead = 0;
            let sectorsToReadAmount = 0,
                allSectors = 0;

            let thisTrackSectorRanges: [number, number][] = [];
            let metadataSectionBlacklist: number[][] = [];
            let sectorSplices: { [key: number]: { start?: number, end?: number } } = {};
            const rawAddressToLogical = (data: number[]) => ((data[0] << 8) | data[1]) * 32 + data[2];
            const addFragment = (fragment: Fragment) => {
                let endSector = discAddressToLogical(fragment.end);
                let startSector = discAddressToLogical(fragment.start);
                allSectors += endSector - startSector;
                allSectors += 1;
                thisTrackSectorRanges.push([startSector, endSector]);

                sectorSplices[discAddressToLogical(fragment.start)] = {
                    start: fragment.start.group
                };
                sectorSplices[discAddressToLogical(fragment.end) & ~1] = {
                    end: fragment.end.group
                }
            };
            const isPartOfThisTrack = (logical: number) => thisTrackSectorRanges.some(([start, end]) => logical >= start && logical <= end);
            const fromSectorAddressToString = (raw: number[]) =>
                `${((raw[0] << 8) | raw[1]).toString(16).padStart(4, '0')}.${raw[2].toString(16).padStart(2, '0')}`;

            let lastFragment = trackRootFragment;
            while (lastFragment.link !== 0) {
                addFragment(lastFragment);
                lastFragment = toc.trackFragmentList[lastFragment.link];
            }
            addFragment(lastFragment);

            yield {type: 'callMetadata', chunk: new TextEncoder().encode(JSON.stringify({
                format,
                sectorSplices,
                thisTrackSectorRanges,
                track,
            }))};

            sectorsToReadAmount = (config.sectorsToRead === -1 ? allSectors : Math.min(config.sectorsToRead!, allSectors));

            let absoluteTimeStart = new Date().getTime();

            const sleeper = await this.stateManager.require(WaitForDiscToStopSpinning);
            // 'sleeper.wait' is assigned to a new variable in case a new, alternative way to wait
            // until the exploit is ready is engineered
            const wait = sleeper.wait.bind(sleeper);

            if (config.writeHeader) {
                if (format.startsWith('LP')) {
                    yield {
                        chunk: createWavHeader(format === 'LP2' ? DiscFormat.lp2 : DiscFormat.lp4, sectorsToReadAmount * (2332 - 20 * 11)),
                        type: 'header',
                    };
                } else {
                    // We might as well give it the correct name
                    const sector1 = await readUTOCSector(this.stateManager.factoryIface, 1);
                    const nameToc = parseTOC(null, sector1);
                    const name = getTitleByTrackNumber(nameToc, track + 1);
                    yield {
                        chunk: createAeaHeader(name, (trackRootFragment.mode & ModeFlag.F_STEREO) !== 0 ? 2 : 1, sectorsToReadAmount * 11),
                        type: 'header',
                    };
                }
            }

            await this.iface.gotoTrack(track);
            await this.iface.gotoTime(
                track,
                Math.floor(config.startSeconds! / 3600),
                Math.floor((config.startSeconds! % 3600) / 60),
                config.startSeconds! % 60
            );
            await wait();

            await this.startDownload(track);
            await this.setSectorToRead(0, sectorsToReadAmount + 2);

            if (progressCallback)
                progressCallback({
                    read: sectorsRead,
                    total: sectorsToReadAmount,
                    action: 'SEEK',
                });

            // This is experimental code. It might not work in all cases.
            let sector = 0;

            let sectorPositionsRead: number[] = [];
            let isAfterBlacklist = false;
            let alignmentKnockBack = 0;

            bufferStartTime = new Date().getTime();

            mainLoop: while (sector < 0xfff && !config.shouldCancelImmediately!()) {
                if (sectorsRead >= sectorsToReadAmount && nextSectorBeginInclude === 0) {
                    this.log(`Dumping complete in ${time} / ${new Date().getTime() - absoluteTimeStart} ms!`);
                    await this.finishDownload();
                    return;
                }
                let sectorContent = await this.readNextSector(
                    progressCallback &&
                    ((data) => {
                        progressCallback({
                            read: data.read + sectorsRead,
                            total: sectorsToReadAmount,
                            action: 'CHUNK',
                        });
                    })
                );
                sector++;

                const sectorMetadata = Array.from(sectorContent.subarray(0, 20));
                const currentPosition = sectorMetadata.slice(sectorMetadata.length - 8, sectorMetadata.length - 5);
                const currentLogical = rawAddressToLogical(currentPosition);
                let audioData = sectorContent.subarray(20);
                
                let wasPartOfBeginEndMitigation = false;

                if(nextSectorBeginInclude){
                    audioData = audioData.subarray(0, nextSectorBeginInclude);
                    nextSectorBeginInclude = 0;
                    wasPartOfBeginEndMitigation = true;
                }else if(nextSectorBeginRemove){
                    audioData = audioData.subarray(nextSectorBeginRemove);
                    nextSectorBeginRemove = 0;
                    wasPartOfBeginEndMitigation = true;
                }else if (currentLogical in sectorSplices && config.respectSoundgroupsBoundaries) {
                    let start = sectorSplices[currentLogical].start ?? 0;
                    let end = sectorSplices[currentLogical].end ?? -1;
                    if(start >= 5){
                        start -= 5.5;
                    }
                    const startByte = start * 424;
                    const endByte = end === -1 ? audioData.length : ((end + 1) * 424);
                    if(startByte > audioData.length){
                        nextSectorBeginInclude = startByte - audioData.length;
                        sectorPositionsRead.push(currentLogical);
                        sectorsRead += 1;
                        isAfterBlacklist = false;
                        continue;
                    }
                    if(endByte > audioData.length){
                        nextSectorBeginInclude = endByte - audioData.length + startByte;
                        audioData = audioData.subarray(startByte);
                    }else{
                        audioData = audioData.subarray(startByte, endByte);
                    }
                }

                // this.log(`Read sector 0x${sector.toString(16)} of DRAM. It contains the disc sector 0x${fromSectorAddressToString(currentPosition)}(0x${currentLogical.toString(16)})`);
                invalidSector: if ((!validSector(audioData) && config.verifyValidAtrac) || (!isPartOfThisTrack(currentLogical) && !wasPartOfBeginEndMitigation) || sectorPositionsRead.includes(currentLogical)) {
                    if (sectorContent.length === 2352 && metadataSectionBlacklist.some((e) => arrayShallowEquals(sectorMetadata, e))) {
                        this.log(
                            `Read sector with metadata block in the blacklist (@${fromSectorAddressToString(
                                currentPosition
                            )}). It will be skipped.`
                        );
                        if (isAfterBlacklist) {
                            sectorsRead++;
                            isAfterBlacklist = false;
                        }
                        continue;
                    }
                    if (sector < 100) {
                        // This can be considered a bad sector
                        const behavior = await config.handleBadSector!(fromSectorAddressToString(currentPosition), sector);
                        if (behavior === 'skip') continue;
                        if (behavior === 'abort') break mainLoop;
                        if (behavior === 'yieldanyway') break invalidSector;
                        // if behavior === 'reload', do as previously.
                    }
                    // We're past the ATRAC data and are reading garbage data from the device's DRAM.
                    // Calculate the time offset, move the head using standard netmd commands.
                    // The 704/11025 fraction is a simplified version of (11/2) * (512/44100), which expresses
                    // 11 soundgroups/2 sectors, where each soundgroup contain 512 samples / sample rate of 44100
                    let originalSeconds = sectorsRead * (704 / 11025) - alignmentKnockBack;
                    if (format !== 'SPS') {
                        // It's not SP Stereo
                        // Use the reverse of the functions used in the gotoTrack handler within the firmware, to convert the "SP" time
                        // SP time   >>   LP time   >>   SP time
                        // \_____/        \______/       \_____/
                        //   \/              \/             \/
                        // local var     time given     time converted
                        //  seconds     to gotoTrack     back within
                        //                               the firmware
                        //                               (@0x00012526 for B1.600)
                        let representation = timeToRepresentation(originalSeconds);
                        switch (format) {
                            case 'SPM':
                            case 'LP2':
                                translateRepresentationFromLP2Mono(representation);
                                break;
                            case 'LP4':
                                translateRepresentationFromLP4(representation);
                                break;
                        }
                        originalSeconds = representationToTime(representation);
                    }
                    let thisBufferTime = new Date().getTime() - bufferStartTime;
                    this.log(
                        `The sector read is not an ATRAC sector. Sectors read previously add up to ${originalSeconds} seconds. Jumping to that time`
                    );
                    metadataSectionBlacklist.push([...sectorMetadata]);
                    isAfterBlacklist = true;

                    let alignmentTries = 0;
                    let thisAlignmentKnockBack = 0;
                    for (; ;) {
                        let seconds = config.startSeconds! + originalSeconds - thisAlignmentKnockBack;
                        let hours = Math.floor(seconds / 3600);
                        seconds -= hours * 3600;
                        let minutes = Math.floor(seconds / 60);
                        seconds -= minutes * 60;

                        this.log(
                            `Jumping to ${hours}:${minutes}:${seconds} (knockback: ${thisAlignmentKnockBack} + ${alignmentKnockBack})`
                        );

                        if (progressCallback)
                            progressCallback({
                                read: sectorsRead,
                                total: sectorsToReadAmount,
                                action: 'SEEK',
                            });

                        await this.finishDownload(); // Switch back to normal commands.
                        await sleep(1000);
                        await this.iface.stop();
                        let tries = 0;
                        while (true) {
                            try {
                                await this.iface.gotoTime(track, hours, minutes, seconds);
                                break;
                            } catch (ex) {
                                this.log('While jumping');
                                console.log(ex);
                                if (tries++ > 5) {
                                    throw new Error('Cannot jump to time!');
                                }
                                await sleep(1000);
                            }
                        }
                        await this.iface.stop();
                        await wait();
                        await this.startDownload(track); // Switch to ATRAC recovery.

                        await this.setSectorToRead(0, 1);

                        let syncSector = await this.readNextSector();
                        let position = Array.from(syncSector.slice(20 - 8, 20 - 5));
                        this.log(`After moving the head, position is ${position.map((n) => n.toString(16).padStart(2, '0')).join('')}`);

                        let alignmentPosition = [...sectorPositionsRead].reverse().indexOf(rawAddressToLogical(position));
                        if (alignmentPosition !== -1) alignmentPosition++;

                        if (alignmentPosition === -1) {
                            // Cannot align.
                            if (alignmentTries < 3) {
                                alignmentTries++;
                                thisAlignmentKnockBack += 2; // Try to align
                                continue;
                            }
                            this.log('DEBUG');
                            this.log('Could not align!');
                            this.log(`originalSeconds=${originalSeconds}`);
                            this.log(`thisAlignmentKnockBack=${thisAlignmentKnockBack}`);
                            this.log(`alignmentKnockBack=${alignmentKnockBack}`);
                            this.log(
                                `syncSector=${Array.from(syncSector)
                                    .map((n) => n.toString(16).padStart(2, '0'))
                                    .join('')}`
                            );
                            this.log(`sectorPositionsRead=${sectorPositionsRead.join(', ')}`);
                            this.log('DEBUG END');
                            await this.finishDownload();
                            throw new Error('Cannot align!');
                        }
                        sector = 0;
                        alignmentTries = 0;
                        this.log(`Aligned! Running ${alignmentPosition} sectors behind!`);
                        yield { type: 'dramSplit' };
                        time += thisBufferTime;
                        bufferStartTime = new Date().getTime();
                        await this.setSectorToRead(alignmentPosition, sectorsToReadAmount - sectorsRead + 2);
                        alignmentKnockBack += thisAlignmentKnockBack;
                        break;
                    }
                    continue;
                }
                // It's a valid ATRAC-containing sector.
                // Add its position to the list of already done sectors.
                sectorPositionsRead.push(currentLogical);
                if (config.includeMetadataSection) yield { chunk: new Uint8Array(sectorMetadata), type: 'metadata' };
                if ((format.startsWith('LP') && config.removeLPBytes === 'auto') || config.removeLPBytes === 'always') {
                    // It's LP - remove the SP compatibility bytes.
                    // There are 12 zero-bytes at the start or each frame
                    // and 8 at the end.
                    const sectorAsArray = Array.from(audioData);
                    for (let frame = 10; frame >= 0; frame--) {
                        const frameStartAddress = frame * 212; // 212 - one ATRAC sound frame.
                        sectorAsArray.splice(frameStartAddress + 212 - 8, 8);
                        sectorAsArray.splice(frameStartAddress, 12);
                    }
                    yield {
                        chunk: new Uint8Array(sectorAsArray),
                        type: 'audioData',
                    };
                } else {
                    yield {
                        chunk: audioData,
                        type: 'audioData',
                    };
                }
                sectorsRead += 1;
                // We got a good sector, so this is no longer true
                isAfterBlacklist = false;
                progressCallback?.({
                    read: sectorsRead,
                    total: sectorsToReadAmount,
                    action: 'READ',
                    sector: fromSectorAddressToString(currentPosition),
                });
            }
        } catch (ex) {
            await this.finishDownload(); // If anything goes wrong, at least try to put the device back into a usable state.
            throw ex;
        }
    }
}
