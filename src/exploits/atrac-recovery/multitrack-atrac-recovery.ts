import { createAeaHeader, readUTOCSector } from "netmd-js";
import { Exploit } from "../../exploit";
import { AtracRecovery, AtracRecoveryConfig } from "./atrac-recovery-interface";
import { getTitleByTrackNumber, parseTOC, ToC } from "netmd-tocmanip";
import { concatUint8Arrays } from "netmd-js/dist/utils";

export class MultitrackATRACRecovery extends Exploit {
    static _name = "MultitrackATRACRecovery";
    public backend?: AtracRecovery;
    private cachedToc?: ToC;

    async init(backend: AtracRecovery){
        this.backend = backend;
    }

    protected getPropertyStore() {
        return {
            checkAddress: {
                'S1.600': 0x0006cf94,
                'S1.500': 0x0006c5d4,
                'S1.400': 0x0006bf30,
                'S1.300': 0x000688ec,
                'S1.200': 0x000673b8,
                'S1.100': 0x00066ae0,
                'S1.000': 0x0006d0f4,

                'R1.400': 0x00030800,
                'R1.300': 0x00030780,
                'R1.200': 0x000306e8,
                'R1.100': 0x0003009c,
                'R1.000': 0x0002fc4c,
            },
            checkContents: {
                '*': new Uint8Array([0x70, 0x47, 0x70, 0x47]),
            },
        }
    }

    // prepareUnit() patches the NetMD portable to make it accept MD Data discs.
    async prepareUnit(){
        await this.stateManager.patch(
            this.getProperty('checkAddress'),
            this.getProperty('checkContents'),
        );
    }

    public setCachedToC(toc: ToC) {
        this.cachedToc = toc;
    }

    private async getToC() {
        if(!this.cachedToc) {
            const tocS0 = await readUTOCSector(this.stateManager.factoryIface, 0);
            const tocS1 = await readUTOCSector(this.stateManager.factoryIface, 1);
            this.cachedToc = parseTOC(tocS0, tocS1);
        }
        return this.cachedToc;
    }


    // This function will return a multitrack AEA file.
    // Track is 0-indexed
    async downloadMultitrackTrack(
        track: number,
        progressCallback?: (data: { read: number; total: number; action: 'READ' | 'SEEK' | 'CHUNK'; sector?: string }) => void,
        otherConfig?: AtracRecoveryConfig
    ) {
        // We need the TOC to derive if this is a 4-track or 8-track recording
        // The player has no clue
        const toc = await this.getToC();
        const rootFragment = toc.trackFragmentList[toc.trackMap[track + 1]];

        if(rootFragment.mode !== 201 && rootFragment.mode !== 200) {
            throw new Error("Not a known multitrack format!");
        }
        const channelCount = rootFragment.mode === 201 ? 8 : 4;
        const trackName = getTitleByTrackNumber(toc, track + 1);

        // Download the actual raw track contents
        const rawData = await this.backend!.downloadTrack(
            track,
            progressCallback,
            {
                ...(otherConfig ?? {}),
                removeLPBytes: 'never',
                writeHeader: false,
                respectSoundgroupsBoundaries: true,
                forceSeekCalculationMode: 'SPS',
            }
        );

        const header = createAeaHeader(trackName, channelCount);

        // Create the final file and return it
        return otherConfig?.writeHeader === false ? rawData : concatUint8Arrays(header, rawData);
    }
}
