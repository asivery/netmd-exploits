import { createAeaHeader, readUTOCSector } from "netmd-js";
import { Exploit } from "../../exploit";
import { AtracRecovery } from "./atrac-recovery-interface";
import { getTitleByTrackNumber, parseTOC } from "netmd-tocmanip";
import { concatUint8Arrays } from "netmd-js/dist/utils";

export class MultitrackATRACRecovery extends Exploit {
    static _name = "MultitrackATRACRecovery";
    private backend?: AtracRecovery;

    async init(backend: AtracRecovery){
        this.backend = backend;
    }

    protected getPropertyStore() {
        return {
            checkAddress: {
                'S1.600': 0x0006cf94,
            },
            checkContents: {
                'S1.600': new Uint8Array([0x70, 0x47, 0x70, 0x47]),
            },
        }
    }

    // prepareUnit() patches the NetMD portable to make it accept MD Data discs.
    async prepareUnit(){
        await this.stateManager.patch(
            this.getProperty('checkAddress'),
            this.getProperty('checkContents'),
        );
    }
    
    
    // This function will return a multitrack AEA file.
    // Track is 0-indexed
    async downloadMultitrackTrack(
        track: number,
        progressCallback?: (data: { read: number; total: number; action: 'READ' | 'SEEK' | 'CHUNK'; sector?: string }) => void,
    ) {
        // We need the TOC to derive if this is a 4-track or 8-track recording
        // The player has no clue
        const tocS0 = await readUTOCSector(this.stateManager.factoryIface, 0);
        const tocS1 = await readUTOCSector(this.stateManager.factoryIface, 1);
        const toc = parseTOC(tocS0, tocS1);
        const rootFragment = toc.trackFragmentList[toc.trackMap[track + 1]];

        if(rootFragment.mode !== 201 && rootFragment.mode !== 200) {
            throw new Error("Not a known multitrack format!");
        }
        const channelCount = rootFragment.mode === 201 ? 8 : 4;
        const trackName = getTitleByTrackNumber(toc, track);
        
        // Download the actual raw track contents
        const rawData = await this.backend!.downloadTrack(
            track,
            progressCallback,
            {
                removeLPBytes: 'never',
                writeHeader: false,
                respectSoundgroupsBoundaries: true,
                forceSeekCalculationMode: 'SPS',
            }
        );

        const header = createAeaHeader(trackName, channelCount);
        
        // Create the final file and return it
        return concatUint8Arrays(header, rawData);
    }
}
