import { cleanWrite, MemoryType, writeOfAnyLength } from 'netmd-js';
import { AllocationContext } from '../../exploit';
import { formatUIntQuery } from '../../utils';
import { HiMDUnboundedReading } from '../himd-unbounded-reading';
import { USBCodeExecution } from '../usb-code-execution';
import { AtracRecovery } from './atrac-recovery-interface';

/* The original non-ATRAC bulk transfer initialization code was written by Sir68k (https://github.com/Sir68k). */
export class CachedSectorBulkDownload extends AtracRecovery {
    public static _name = 'CachedSectorBulkDownload';
    getPropertyStore(ctx: AllocationContext) {
        return {
            _macros: {
                "*": {
                    ldr1: { // Read to R1
                        code: `
                            ldr r0, %macro_argument_0
                            ldr r1, [ r0 ]
                        `,
                        properties: {},
                    },
                    wrr1: { // Write R1
                        code: `
                            ldr r0, %macro_argument_0
                            str r1, [ r0 ]
                        `,
                        properties: {},
                    },
                    wrim: { // Write immediate
                        code: `
                            mov r1, %macro_argument_1
                            @wrr1 %macro_argument_0
                        `,
                        properties: {},
                    },
                    wrc: { // Write constant
                        code: `
                            ldr r1, %macro_argument_1
                            @wrr1 %macro_argument_0
                        `,
                        properties: {},
                    }
                },
            },
            init_code: {
                'S*': `
                    _loader:
                        push { r3, r4, r5, r6, r7, lr }

                        ldr r3, patch_spot
                        ldr r4, patch_content
                        mov r5, #$patch_slot_1
                        bl _patch
                        
                        ldr r3, patch_spot
                        add r3, r3, #4
                        ldr r4, resident_code_address
                        mov r5, #$patch_slot_2
                        bl _patch

                        ldr r3, patch_spot_3
                        ldr r4, bx_lr_thumb
                        mov r5, #$patch_slot_3
                        bl _patch

                        pop { r3, r4, r5, r6, r7, lr }
                        bx lr
                        
                        patch_content: .word 0x47004800
                        bx_lr_thumb: .word 0x4770bcf0
                        @bridge word patch_spot patch_spot_3 resident_code_address
                    _patch:
                        @patch
                `,
            },
            prep_code_loader: {
                'S*,H*': `
                    @bxar r0, $prep_code_address
                `,
            },
            prep_code: {
                'S*': `
                    @wrim sector_offset, #0x700
                    @wrim should_cleanup_atrac, #0

                    @ldr1 p_dma_mode
                    bic r1, r1, #1
                    @wrr1 p_dma_mode
                    @wrim p_dma_x, #0
                    @wrim p_z, #0x21
                    @wrc p_dma_mode, const_p_dma_mode

                    @wrc p_usb_mode, const_p_usb_mode
                    @wrc p_uo_100, const_p_uo_100
                    @wrc p_uo_104, const_p_uo_104
                    @wrim p_uo_108, #0x100

                    @ldr1 p_uo_108
                    bic r1, r1, #512
                    @wrr1 p_uo_108
                    
                    @ldr1 p_uo_100
                    mov r0, #0x100
                    orr r1, r1, r0
                    @wrr1 p_uo_100
                    
                    bx lr

                    const_p_dma_mode:   .word 0x33D0040
                    const_p_usb_mode:   .word 0x7310100
                    const_p_uo_100:     .word 0x800
                    const_p_uo_104:     .word 0xf301

                    @bridge word sector_start sector_offset sector_buffer should_cleanup_atrac
                    @bridge word p_dma_mode p_dma_x p_z p_usb_mode p_uo_100 p_uo_104 p_uo_108
                `,
                'Hr*,Hn*': `
                    ; Sector_end => bytes_count in himd
                    ; Sector_start => bytes_start in himd

                    ldr r0, sector_start
                    ldr r0, [ r0 ]
                    ldr r1, sector_end
                    @bxar r2, $usb_bulk_dma_func

                    @bridge word sector_start sector_end
                `,
            },
            cleanupCode: {
                '*': `@autogen_cleanup $patch_slot_1, $patch_slot_2, $patch_slot_3`
            },
            bulk_transfer_code: {
                'S*': `
                    @fw_compat_bridge
                    ; The resident code responsible for handling bulk transfers
                    ; Main check
                    @ldr1 p_usb_state
                    lsrs r1, r1, #0x1a
                    bcc return

                    ; Main non-interrupt loop
                    loop:
                        @ldr1 p_uo_104
                        lsrs r1, r1, #9
                        bcc loop
                        
                        @wrim p_uo_104, #0x100

                        @ldr1 sector_offset
                        mov r0, #608
                        cmp r1, r0
                        bhs next_sector

                        send_sector:
                            @wrc p_uo_100, const_p_uo_100
                            @ldr1 sector_offset
                            lsl r1, r1, #2 ; *4
                            ldr r0, sector_buffer
                            add r1, r1, r0
                            @wrr1 p_dma_src
                            @wrc p_dma_dst, p_uo_114
                            @wrim p_dma_count, #32

                            @wrc p_dma_mode, const_p_dma_mode
                            @ldr1 sector_offset
                            add r1, r1, #32
                            @wrr1 sector_offset
                            b loop

                        next_sector:
                            @ldr1 should_cleanup_atrac
                            cmp r1, #0
                            beq _nokill
                            ldr r0, p_dram_transfer_ctl_a
                            mov r1, #0xa0
                            strb r1, [ r0 ]
                            ldrb r1, [ r0 ]
                            mov r2, #0x80
                            bic r1, r1, r2
                            strb r1, [ r0 ]
                            _nokill:
                            @wrim should_cleanup_atrac, #1


                            ldr r3, sector_start
                            ldr r0, [ r3 ]
                            ldr r1, sector_end
                            ldr r1, [ r1 ]
                            cmp r0, r1
                            bhs return

                            add r2, r0, #1
                            str r2, [ r3 ]

                            mov r1, #0
                            mov r3, #152
                            lsl r3, r3, #4
                            @blxar r4, $read_atrac_dram
                            ; A very temporary solution. The contents of this function should be pasted here instead.

                            @wrim sector_offset, #0
                            b send_sector

                    return:
                        pop { r4, r5, r7 }
                        pop { r3 }
                        bx r3
                    
                    const_p_uo_100:         .word 0x0800100
                    const_p_dma_mode:       .word 0x33D0041
                    @bridge word sector_offset sector_start sector_end sector_buffer should_cleanup_atrac
                    @bridge word p_usb_state p_uo_104 p_uo_100 p_uo_114 p_dma_src p_dma_dst p_dma_count p_dma_mode
                    @bridge word p_dram_transfer_ctl_a
                `,
            },
            
            resident_code_address:  { '*': ctx.allocate(512) },
            prep_code_address:      { '*': ctx.allocate(256) },
            sector_offset:          { '*': ctx.allocate(4) },
            sector_start:           { '*': ctx.allocate(4) },
            sector_end:             { '*': ctx.allocate(4) },
            should_cleanup_atrac:   { '*': ctx.allocate(4) },
            sector_buffer:          { '*': 0x03808000, 'Hn*': 0x05009400, 'Hr*': 0x05030900 },
            patch_slot_1:           { '*':  this.patchSlot1 },
            patch_slot_2:           { '*':  this.patchSlot2 },
            patch_slot_3:           { '*':  this.patchSlot3 },

            // USB
            p_usb_state:            { "S*": 0x0380c010 },
            p_usb_mode:             { "S*": 0x0380c014 },
            p_uo_100:               { "S*": 0x0380c100 },
            p_uo_104:               { "S*": 0x0380c104 },
            p_uo_108:               { "S*": 0x0380c108 },
            p_uo_10c:               { "S*": 0x0380c10c },
            p_uo_114:               { "S*": 0x0380c114 },

            // DMA
            p_dma_src:              { 'S*': 0x03803000 },
            p_dma_dst:              { 'S*': 0x03803004 },
            p_dma_count:            { 'S*': 0x03803008 },
            p_dma_mode:             { 'S*': 0x0380300c },
            p_dma_x:                { 'S*': 0x03803044 },
            p_z:                    { 'S*': 0x03804040 },

            p_dram_transfer_ctl_a:  { 'S*': 0x0300b114 },

            patch_spot: { 
                'S1.600': 0x000780a0,
                'S1.500': 0x000776a8,
                'S1.400': 0x00076fd4,
                'S1.300': 0x00073914,
                'S1.200': 0x00072260,
                'S1.100': 0x000718d8,
                'S1.000': 0x00078208,
            },
            patch_spot_3: { 
                'S1.600': 0x00078264,
                'S1.500': 0x0007786c,
                'S1.400': 0x00077198,
                'S1.300': 0x00073ad8,
                'S1.200': 0x00072424,
                'S1.100': 0x00071a9c,
                'S1.000': 0x000783cc,
            },

            usb_bulk_dma_func: {
                'Hr1.000': 0x000b3c0d,
                'Hn1.100': 0x000bdef1,
                'Hn1.200': 0x000bdf5d,
            },
        };
    }


    currentTrack = -1;
    patchSlot1: number = -1;
    patchSlot2: number = -1;
    patchSlot3: number = -1;
    cachedSectors: Uint8Array = new Uint8Array();
    cachedSectorsPtr: number = 0;
    currentSector: number = 0;
    sectorsRemaining: number = 0;

    async init() {
        await super.init();
        await this.stateManager.require(HiMDUnboundedReading);
        await writeOfAnyLength(
            this.factoryIface,
            this.getProperty('prep_code_address'),
            this.assembleProperty('prep_code'),
            MemoryType.MAPPED
        );
        this.log("Prep OK!");
        if(!this.stateManager.device.isHimd){
            this.patchSlot1 = this.stateManager.getIncrementalPatchNumber();
            this.patchSlot2 = this.stateManager.getIncrementalPatchNumber();
            this.patchSlot3 = this.stateManager.getIncrementalPatchNumber();
            await writeOfAnyLength(
                this.factoryIface,
                this.getProperty('resident_code_address'),
                this.assembleProperty('bulk_transfer_code'),
                MemoryType.MAPPED
            );
            this.log("Resident OK!");
            const usbExecution = await this.stateManager.require(USBCodeExecution);
            await usbExecution.execute(this.assembleProperty('init_code'));
        }
        this.log('Init OK!');
    }

    async unload() { 
        // As this exploit patches the USB code, we can't depend on the stateManager to free the patches
        if(!this.stateManager.device.isHimd){
            const usbExecution = await this.stateManager.require(USBCodeExecution);
            await usbExecution.execute(this.assembleProperty('cleanupCode'));
            this.stateManager.freePatch(this.patchSlot1);
            this.stateManager.freePatch(this.patchSlot2);
            this.stateManager.freePatch(this.patchSlot3);
        }
    }

    async reloadBuffer(sectorsCount: number, callback?: ((data: { read: number; length: number }) => void)) {
        let sectorStartContent = 0, sectorEndContent = 0, sectorLength = 0;
        if(this.stateManager.device.isHimd){
            sectorLength = 2368;
            sectorStartContent = this.getProperty("sector_buffer") + 2368 * this.currentSector;
            if(sectorsCount + this.currentSector > this.sectorsPerLoad){
                sectorsCount = this.sectorsPerLoad - this.currentSector;
            }
            if(sectorsCount === 0){
                // Would deadlock the device
                // Generate a fake sector. As the sector is of incorrect length, this will trigger
                // The buffer flushing code in the main exploit.
                this.cachedSectorsPtr = 0;
                this.cachedSectors = new Uint8Array(20).fill(255);
                return;
            }
            sectorEndContent = sectorsCount * 2368;
        }else{
            sectorLength = 2432;
            sectorStartContent = this.currentSector;
            sectorEndContent = this.currentSector + sectorsCount;
        }
        await cleanWrite(
            this.factoryIface,
            this.getProperty('sector_start'),
            formatUIntQuery('%<d', sectorStartContent),
            MemoryType.MAPPED
        );
        await cleanWrite(
            this.factoryIface,
            this.getProperty('sector_end'),
            formatUIntQuery('%<d', sectorEndContent),
            MemoryType.MAPPED
        );
        this.log(`[BULK]: Set boundaries to ${this.currentSector} -> ${this.currentSector + sectorsCount}`);
        await (await this.stateManager.require(USBCodeExecution)).execute(this.assembleProperty('prep_code_loader'));
        this.log("All set - begin bulk read!");
        this.cachedSectorsPtr = 0;
        this.cachedSectors = new Uint8Array(
            await this.stateManager.iface.netMd.readBulkToArray(
                sectorsCount * sectorLength,
                sectorsCount * sectorLength,
                callback && ((length, read) => callback({ read: Math.floor(read / sectorLength), length: sectorsCount }))
            )
        );
    }

    sectorsPerLoad = this.stateManager.device.isHimd ? 3455 : 900;

    async readNextSector(callback?: (data: { read: number; length: number }) => void): Promise<Uint8Array> {
        if (this.currentTrack === -1) throw new Error('You need to startDownload() first');
        if (this.cachedSectorsPtr >= this.cachedSectors.length) {
            await this.reloadBuffer(Math.min(this.sectorsRemaining, this.sectorsPerLoad), callback);
        }
        const slice = this.cachedSectors.slice(this.cachedSectorsPtr, this.cachedSectorsPtr + 2352);
        this.currentSector++;
        this.cachedSectorsPtr += this.stateManager.device.isHimd ? 2368 : 2432;
        return slice;
    }

    async setSectorToRead(sector: number, sectorsRemaining: number): Promise<void> {
        if (this.currentTrack === -1) throw new Error('You need to startDownload() first');
        this.currentSector = sector;
        this.sectorsRemaining = sectorsRemaining;
        // Force cache reload on next sector
        this.cachedSectorsPtr = this.cachedSectors.length + 1;
    }

    async startDownload(track: number): Promise<void> {
        this.currentTrack = track;
    }

    async finishDownload(): Promise<void> {
        this.currentTrack = -1;
    }
}
