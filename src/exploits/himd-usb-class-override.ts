import { formatUIntQuery } from '../utils';
import { MemoryType, scanQuery } from "netmd-js";
import { Exploit } from "../exploit";
import { HiMDUnboundedReading } from "./himd-unbounded-reading";
import { USBCodeExecution } from "./usb-code-execution";
import JSBI from 'jsbi';

export class HiMDUSBClassOverride extends Exploit{
    static _name = "HiMDUSBClassOverride";
    public _policies = {
        permanent: true,
    };

    protected override getPropertyStore() {
        return {
            usbClassOverrideContent: {
                "Hr1.000,Hn1.000,Hn1.100,Hn1.10A,Hn1.200": new Uint8Array([0xFF, 0x00, 0x00, 0x00]),
                "Hx1.0A0,Hx1.090,Hx1.080,Hx1.070,Hx1.060,Hx1.040": new Uint8Array([0x02, 0xFF, 0x00, 0x00]),
            },
            usbClassOverrideAddress: {
                "Hr1.000": 0x000d8adc,

                "Hn1.000": 0x000da1d8,
                "Hn1.100": 0x000d9ed8,
                "Hn1.10A": 0x000d9f60,
                "Hn1.200": 0x000d9cf8,
            },
            usbClassOverrideAddressB: {
                "Hn1.000": 0x000da218,
                "Hn1.200": 0x000d9d38,
            },
            himdDescriptorsPtrsBase: {
                "Hr1.000": 0x000d8b70,

                "Hn1.000": 0x000da26c,
                "Hn1.100": 0x000d9f6c,
                "Hn1.10A": 0x000d9ff4,
                "Hn1.200": 0x000d9d8c,
            },
            himdModifiableDescriptorBase: {
                "Hr1.000": 0x000d8a30,
                
                "Hn1.000": 0x000da174,
                "Hn1.100": 0x000d9e74,
                "Hn1.10A": 0x000d9e6c,
                "Hn1.200": 0x000d9c04,
            },
            newVidPid: {
                "H*": new Uint8Array([0x41, 0x53, 0x56, 0x52]),
            },

            rh1PatchCode: {
                'Hx*': `
                    ; The MZ-RH1 keeps the VID / PID codes in its SRAM, not DRAM / ROM
                    ; For that reason it's impossible to patch these codes like it's done
                    ; with other HiMD devices.

                    ldr r0, rh1VidPidLocation
                    ldr r1, newVidPid
                    str r1, [r0]
                    bx lr

                    @bridge word rh1VidPidLocation
                    @bridge byte newVidPid
                `
            },
            rh1VidPidLocation: {
                'Hx1.0A0,Hx1.090,Hx1.080,Hx1.070,Hx1.060,Hx1.040': 0x0080125c,
            },
            rh1DescriptorLocation: {
                'Hx1.0A0,Hx1.090,Hx1.080,Hx1.070,Hx1.060,Hx1.040': 0x02003568,
            },
        };
    }

    public override async init() {
        if(!this.stateManager.device.isHimd){
            return;
        }
        if(this.stateManager.device.versionCode.startsWith("Hx")){
            // MZ-RH1
            const code = this.assembleProperty("rh1PatchCode");
            const codeExec = await this.stateManager.require(USBCodeExecution);
            await codeExec.execute(code);
            
            // Hard part done.
            // Now patch the USB interface descriptor
            const [descriptorLocation, descriptorContent] = this.getProperties("rh1DescriptorLocation", "usbClassOverrideContent");
            await this.factoryIface.write(descriptorLocation, descriptorContent, MemoryType.MAPPED);
            // Done
            return;
        }
        const descriptorsPtrsBase = this.getProperty("himdDescriptorsPtrsBase");
        await this.stateManager.require(HiMDUnboundedReading);
        const targetDescriptor = this.getProperty("himdModifiableDescriptorBase");
        await this.stateManager.patch(
                descriptorsPtrsBase + 4 * this.stateManager.device.hwid,
                formatUIntQuery("%<d", targetDescriptor),
        );
        const vidPidOffset = targetDescriptor + 8;
        await this.stateManager.patch(
            vidPidOffset,
            this.getProperty("newVidPid"),
        );

        let usbClassOverrideAddress = this.getProperty("usbClassOverrideAddress"),
            usbClassOverrideContent = this.getProperty("usbClassOverrideContent");

        if(this.getPropertyOrNull("usbClassOverrideAddressB") !== null){
            const deviceCapabilitiesBinary = await this.factoryIface.read(this.getFirmwareProperty("device_capabilities_address"), 4, MemoryType.MAPPED);
            const deviceCapabilities = JSBI.toNumber(scanQuery(deviceCapabilitiesBinary, "%<d")[0] as JSBI);
            if(((deviceCapabilities >> 8) & 1) !== 0){
                usbClassOverrideAddress = this.getProperty("usbClassOverrideAddressB");
            }
        }

        await this.stateManager.patch(
            usbClassOverrideAddress,
            usbClassOverrideContent,
        );
    }

}
