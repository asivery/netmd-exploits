import { cleanRead, MDTrack, MemoryType, patch, Wireformat } from "netmd-js";
import { Exploit, VersionPropertyStore } from "../exploit";

// Exploit based on @Sir68k's work (https://github.com/Sir68k)
export class SPUpload extends Exploit {
    static _name = "SPUpload";

    public _policies = {
        stateManagerUnpatchLegal: true,
    };

    protected getPropertyStore(): VersionPropertyStore {
        return {
            fiqHandlerTypeAddress: {
                'S1.600': 0x02003eff + 208,
                'S1.500': 0x02003fc7,
                'S1.200': 'fiqHandlerBPatch0',
            },
            fiqHandlerAPatch0: {
                'S1.600': 0x0007f408,
                'S1.500': 0x0007e988,
            },
            fiqHandlerBPatch0: {
                'S1.600': 0x0007efec,
                'S1.500': 0x0007e56c,
                'S1.200': 0x00078dcc,
            },


            prepPatchCommon: {
                'S1.600': 0x00077c04,
                'S1.500': 0x0007720c,
                'S1.200': 0x00071e5c,
            },
            fiqHandlerCommon1: {
                'S1.600': 0x0007f4e8,
                'S1.500': 0x0007ea68,
                'S1.200': 0x00078eac,
            },
            fiqHandlerCommon2: {
                'S1.600': 0x0007f4ec,
                'S1.500': 0x0007ea6c,
                'S1.200': 0x00078eb0,
            },
            trackType: {
                'S1.600': 0x000852b0,
                'S1.500': 0x00084820,
                'S1.200': 0x0007ea9c,
            },


            fiqHandlerPatch0Contents: {
                'S*': new Uint8Array([0x00,0x00,0xa0,0xe1]),
            },
            fiqHandlerPatch1Contents: {
                'S*': new Uint8Array([0x14,0x80,0x80,0x03]),
            },
            fiqHandlerPatch2Contents: {
                'S*': new Uint8Array([0x14,0x90,0x80,0x03]),
            },
            prepPatchContents: {
                'S*': new Uint8Array([0x0D,0x31,0x01,0x60]),
            },
            trackTypeContents: {
                'S*': new Uint8Array([6,2,0,4]), // SP, LP2, LP4, MONO
            },
        }
    }

    async init(channels: 1 | 2) {
        await super.init();
        const variantProp = this.getProperty("fiqHandlerTypeAddress");

        let addressAPropName;
        if(typeof variantProp === "string"){
            addressAPropName = variantProp;
        }else{
            const variant = (await cleanRead(
                this.factoryIface,
                variantProp,
                1,
                MemoryType.MAPPED,
            ))[0];
            if(variant !== 1){
                addressAPropName = "fiqHandlerAPatch0";
            }else{
                addressAPropName = "fiqHandlerBPatch0";
            }
        }
        let addressA = this.getProperty(addressAPropName);
        await patch(
            this.factoryIface,
            addressA,
            this.getProperty("fiqHandlerPatch0Contents"),
            this.stateManager.getIncrementalPatchNumber(),
            this.stateManager.getMaxPatchesAmount(),
        );
        await patch(
            this.factoryIface,
            this.getProperty("fiqHandlerCommon1"),
            this.getProperty("fiqHandlerPatch1Contents"),
            this.stateManager.getIncrementalPatchNumber(),
            this.stateManager.getMaxPatchesAmount(),
        );
        await patch(
            this.factoryIface,
            this.getProperty("fiqHandlerCommon2"),
            this.getProperty("fiqHandlerPatch2Contents"),
            this.stateManager.getIncrementalPatchNumber(),
            this.stateManager.getMaxPatchesAmount(),
        );
        await patch(
            this.factoryIface,
            this.getProperty("prepPatchCommon"),
            this.getProperty("prepPatchContents"),
            this.stateManager.getIncrementalPatchNumber(),
            this.stateManager.getMaxPatchesAmount(),
        );
        
        const trackTypeContents = this.getProperty("trackTypeContents");
        trackTypeContents[1] = channels === 1 ? 4 : 6;
        await patch(
            this.factoryIface,
            this.getProperty("trackType"),
            trackTypeContents,
            this.stateManager.getIncrementalPatchNumber(),
            this.stateManager.getMaxPatchesAmount(),
        );
    }

    prepareTrack(track: MDTrack) {
        // Transcribe the track and call session's method.
        
        // In order to re-align the data with the DRAM buffer,
        // (floor(2332 / 105) + 1) * 105 - 2332 padding bytes need to be added

        const padding = 100;
        const paddingArray = new Uint8Array(padding).fill(0);
        
        const raw = new Uint8Array(track.data);
        const originalLength = raw.length;
        const slices: Uint8Array[] = [];
        for(let i = 0; i<originalLength; i += 2332){
            const sector = raw.subarray(i, i + 2332)
            slices.push(sector);
            // Rewrite Block Size Mode and the number of Block Floating Units
            // This mitigates an issue with atracdenc where it doesn't write
            // the bytes at the end of each frame.
            for(let i = 0; i<sector.length; i += 212){
                sector[i + 212 - 1] = sector[i + 0];
                sector[i + 212 - 2] = sector[i + 1];
            }
            slices.push(paddingArray);
        }
        track = new MDTrack(
            track.title,
            Wireformat.l105kbps,
            concatUint8Arrays(slices).buffer,
            track.chunkSize,
            track.fullWidthTitle,
            track.encryptPacketsIterator
        );
        track.getFrameCount = () => originalLength / 212;

        return track;
    }

}

function concatUint8Arrays(args: Uint8Array[]) {
    let totalLength = 0;
    for (let a of args) {
        totalLength += a.length;
    }

    let res = new Uint8Array(totalLength);

    let offset = 0;
    for (let a of args) {
        res.set(a, offset);
        offset += a.length;
    }
    return res;
}
