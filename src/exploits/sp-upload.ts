import { cleanRead, MDTrack, MemoryType, patch, Wireformat } from "netmd-js";
import { Exploit, VersionPropertyStore } from "../exploit";

// Exploit based on @Sir68k's work (https://github.com/Sir68k)
export class SPUpload extends Exploit {
    static _name = "SPUpload";

    public _policies = {
        stateManagerUnpatchLegal: true,
    };

    protected getPropertyStore(): VersionPropertyStore {
        return {
            fiqHandlerTypeAddress: {
                'S1.600': 0x02003eff + 208,
                'S1.500': 0x02003fc7,
                'S1.400': 0x03000220,
                'S1.300': 0x02003e97,
                'S1.200': 'fiqHandlerBPatch0',
                'S1.100': 'fiqHandlerBPatch0',
                'S1.000': 0x0200401b,
            },
            fiqHandlerAPatch0: {
                'S1.600': 0x0007f408,
                'S1.500': 0x0007e988,
                'S1.400': 0x0007e2c8,
                'S1.300': 0x0007aa00,


                'S1.000': 0x0007f59c,
            },
            fiqHandlerBPatch0: {
                'S1.600': 0x0007efec,
                'S1.500': 0x0007e56c,
                'S1.400': 0x0007deac,
                'S1.300': 0x0007a5e4,
                'S1.200': 0x00078dcc,
                'S1.100': 0x000783c0,
                'S1.000': 0x0007f180,
            },


            prepPatchCommon: {
                'S1.600': 0x00077c04,
                'S1.500': 0x0007720c,
                'S1.400': 0x00076b38,
                'S1.300': 0x00073488,
                'S1.200': 0x00071e5c,
                'S1.100': 0x000714d4,
                'S1.000': 0x00077d6c,
            },
            fiqHandlerCommon1: {
                'S1.600': 0x0007f4e8,
                'S1.500': 0x0007ea68,
                'S1.400': 0x0007e3a8,
                'S1.300': 0x0007aae0,
                'S1.200': 0x00078eac,
                'S1.100': 0x000784a0,
                'S1.000': 0x0007f67c,
            },
            fiqHandlerCommon2: {
                'S1.600': 0x0007f4ec,
                'S1.500': 0x0007ea6c,
                'S1.400': 0x0007e3ac,
                'S1.300': 0x0007aae4,
                'S1.200': 0x00078eb0,
                'S1.100': 0x000784a0,
                'S1.000': 0x0007f680,
            },
            trackType: {
                'S1.600': 0x000852b0,
                'S1.500': 0x00084820,
                'S1.400': 0x00084160,
                'S1.300': 0x00080798,
                'S1.200': 0x0007ea9c,
                'S1.100': 0x0007e084,
                'S1.000': 0x00085444,
            },


            fiqHandlerPatch0Contents: {
                'S*': new Uint8Array([0x00, 0x00, 0xa0, 0xe1]),
            },
            fiqHandlerPatch1Contents: {
                'S*': new Uint8Array([0x14, 0x80, 0x80, 0x03]),
            },
            fiqHandlerPatch2Contents: {
                'S*': new Uint8Array([0x14, 0x90, 0x80, 0x03]),
            },
            prepPatchContents: {
                'S*': new Uint8Array([0x0D, 0x31, 0x01, 0x60]),
            },
            trackTypeContents: {
                'S*': new Uint8Array([6, 2, 0, 4]), // SP, LP2, LP4, MONO
            },
        }
    }

    async init(channels: 1 | 2) {
        await super.init();
        const variantProp = this.getProperty("fiqHandlerTypeAddress");

        let addressAPropName;
        if (typeof variantProp === "string") {
            addressAPropName = variantProp;
        } else {
            const variant = (await cleanRead(
                this.factoryIface,
                variantProp,
                1,
                MemoryType.MAPPED,
            ))[0];
            if (variant !== 1) {
                addressAPropName = "fiqHandlerAPatch0";
            } else {
                addressAPropName = "fiqHandlerBPatch0";
            }
        }
        let addressA = this.getProperty(addressAPropName);
        await patch(
            this.factoryIface,
            addressA,
            this.getProperty("fiqHandlerPatch0Contents"),
            this.stateManager.getIncrementalPatchNumber(),
            this.stateManager.getMaxPatchesAmount(),
        );
        await patch(
            this.factoryIface,
            this.getProperty("fiqHandlerCommon1"),
            this.getProperty("fiqHandlerPatch1Contents"),
            this.stateManager.getIncrementalPatchNumber(),
            this.stateManager.getMaxPatchesAmount(),
        );
        await patch(
            this.factoryIface,
            this.getProperty("fiqHandlerCommon2"),
            this.getProperty("fiqHandlerPatch2Contents"),
            this.stateManager.getIncrementalPatchNumber(),
            this.stateManager.getMaxPatchesAmount(),
        );
        await patch(
            this.factoryIface,
            this.getProperty("prepPatchCommon"),
            this.getProperty("prepPatchContents"),
            this.stateManager.getIncrementalPatchNumber(),
            this.stateManager.getMaxPatchesAmount(),
        );

        const trackTypeContents = this.getProperty("trackTypeContents");
        trackTypeContents[1] = channels === 1 ? 4 : 6;
        await patch(
            this.factoryIface,
            this.getProperty("trackType"),
            trackTypeContents,
            this.stateManager.getIncrementalPatchNumber(),
            this.stateManager.getMaxPatchesAmount(),
        );
    }

    prepareTrack(track: MDTrack) {
        // Transcribe the track and call session's method.

        // In order to re-align the data with the DRAM buffer,
        // (floor(2332 / 105) + 1) * 105 - 2332 padding bytes need to be added

        const padding = 100;
        const paddingArray = new Uint8Array(padding).fill(0);

        const raw = new Uint8Array(track.data);
        const originalLength = raw.length;
        const slices: Uint8Array[] = [];
        for (let i = 0; i < originalLength; i += 2332) {
            const sector = raw.subarray(i, i + 2332)
            slices.push(sector);
            // Rewrite Block Size Mode and the number of Block Floating Units
            // This mitigates an issue with atracdenc where it doesn't write
            // the bytes at the end of each frame.
            for (let i = 0; i < sector.length; i += 212) {
                sector[i + 212 - 1] = sector[i + 0];
                sector[i + 212 - 2] = sector[i + 1];
            }
            slices.push(paddingArray);
        }
        track = new MDTrack(
            track.title,
            Wireformat.l105kbps,
            concatUint8Arrays(slices).buffer,
            track.chunkSize,
            track.fullWidthTitle,
            track.encryptPacketsIterator
        );
        track.getFrameCount = () => originalLength / 212;

        return track;
    }

}

function concatUint8Arrays(args: Uint8Array[]) {
    let totalLength = 0;
    for (let a of args) {
        totalLength += a.length;
    }

    let res = new Uint8Array(totalLength);

    let offset = 0;
    for (let a of args) {
        res.set(a, offset);
        offset += a.length;
    }
    return res;
}
