import { cleanRead, MemoryOpenType, MemoryType } from 'netmd-js';
import { Exploit, VersionPropertyStore } from '../exploit';
import { findBytes, formatUIntQuery } from '../utils';

export class FirmwareDumper extends Exploit {
    public static _name = 'FirmwareDumper';

    protected getPropertyStore(): VersionPropertyStore {
        return {
            romSize: {
                'R*': 0x70000,
                'S*': 0xa0000,
            },
            ramSize: {
                'R*': 0x4800,
                'S*': 0x9000,
            },
        };
    }

    async readFirmware(callback: (progress: { type: 'RAM' | 'ROM' | 'DRAM' ; readBytes: number; totalBytes: number }) => void = () => {}) {
        if(this.stateManager.device.versionCode.startsWith("Hx")){
            // The MZ-RH1 firmware dumping patch. All credits go to Sir68k
            /*
                sub r0, r0, #0x04000000
                add r3, r0, #0x10
                subs pc, lr, #8
            */
            const rh1DRAMCode = new Uint8Array([0x01, 0x03, 0x40, 0xe2, 0x10, 0x30, 0x80, 0xe2, 0x08, 0xf0, 0x5e, 0xe2]);

            /*
                movs pc, #0x02000000
            */
            const rh1PatchCode = new Uint8Array([0x02, 0xf4, 0xa0, 0xe3]);

            await this.stateManager.patch(0x10, rh1PatchCode, 0);
            await this.factoryIface.write(0x02000000, rh1DRAMCode, MemoryType.MAPPED);
            console.log(await this.factoryIface.read(0x02000000, 0x10, MemoryType.MAPPED));
            console.log(await this.factoryIface.getDeviceCode());

            let memorySlices: Uint8Array[] = []
            for(let offset = 0x04000000; offset < 0x04100000; offset += 0x10){
                memorySlices.push(await this.factoryIface.read(offset, 0x10, MemoryType.MAPPED));
                callback?.({ type: 'ROM', readBytes: offset - 0x04000000, totalBytes: 0x00100000});
            }
            const rom = concatUint8Arrays(memorySlices);
            memorySlices = [];
            for(let offset = 0x04800000; offset < 0x04808000; offset += 0x10){
                memorySlices.push(await this.factoryIface.read(offset, 0x10, MemoryType.MAPPED));
                callback?.({ type: 'RAM', readBytes: offset - 0x04800000, totalBytes: 0x8000 });
            }
            const ram = concatUint8Arrays(memorySlices);
            memorySlices = [];
            for(let offset = 0x02000000; offset < 0x03000000; offset += 0x10){
                memorySlices.push(await this.factoryIface.read(offset, 0x10, MemoryType.MAPPED));
                callback?.({ type: 'DRAM', readBytes: offset - 0x02000000, totalBytes: 0x01000000 });
            }
            const dram = concatUint8Arrays(memorySlices);
            return { ram, rom, dram };
        }else if(this.stateManager.device.versionCode.startsWith("H")){
            // Non-RH1 HiMD device
            await this.factoryIface.changeMemoryState(0x03000040, 0x1a, MemoryType.MAPPED, MemoryOpenType.CLOSE);
            await this.factoryIface.changeMemoryState(0x03000040, 0x1a, MemoryType.MAPPED, MemoryOpenType.READ);
            await this.factoryIface.read(0x03000040, 0x1a, MemoryType.MAPPED);

            let slices: Uint8Array[] = [];
            for(let i = 0; i<0xe0000; i+=0x10){
                slices.push(await this.factoryIface.read(i, 0x10, MemoryType.MAPPED));
                callback?.({ type: "ROM", readBytes: slices.length * 0x10, totalBytes: 0xe0000});
            }
            const rom = concatUint8Arrays(slices);
            slices = [];
            for(let i = 0x00800000; i<0x00810000; i+=0x10){
                slices.push(await this.factoryIface.read(i, 0x10, MemoryType.MAPPED));
                callback?.({ type: "RAM", readBytes: slices.length * 0x10, totalBytes: 0x10000});
            }
            const ram = concatUint8Arrays(slices);
            return { ram, rom };
        }
        // This exploit works by first reading the device's RAM using legal factory mode commands
        // then, in that RAM image, the exploit finds the USB command buffer, which is followed
        // by the allowed memory access ranges written by 'changeMemoryState'. The factory mode
        // allows any RAM address to be overwritten with any value, so nothing is stopping us
        // from rewriting these ranges to zeros, allowing us to start reading at mapped memory
        // address 0x00000000 - the flash ROM - the firmware.

        const [romSize, ramSize] = this.getProperties('romSize', 'ramSize');
        let memorySlices: Uint8Array[] = [];
        callback({ type: 'RAM', readBytes: 0, totalBytes: ramSize });
        for (let i = 0; i < ramSize; i += 0x10) {
            memorySlices.push(await cleanRead(this.factoryIface, 0x02000000 + i, 0x10, MemoryType.MAPPED));
            callback({ type: 'RAM', readBytes: memorySlices.length * 0x10, totalBytes: ramSize });
        }
        callback({ type: 'ROM', readBytes: 0, totalBytes: romSize });
        let fullRam = concatUint8Arrays(memorySlices);

        // Find the factory USB buffer. The allowed ranges should be right behind it.
        const usbBufferBeginning = new Uint8Array([0x00, 0x18, 0x21, 0x00, 0x00]);
        let offset = findBytes(fullRam, usbBufferBeginning);
        let foundRAMBoundsOffset = -1;
        while (offset !== -1) {
            let shouldStartHere = offset + 0x20;
            let possibleValue = Math.floor(shouldStartHere / 16) * 16 + 0x02000000;
            let calculated = formatUIntQuery('%<d', possibleValue);
            let broken = false;
            for (let i = 0; i < 4; i++) {
                if (calculated[i] !== fullRam[shouldStartHere + i]) {
                    broken = true;
                    break;
                }
            }
            if (!broken) {
                foundRAMBoundsOffset = shouldStartHere + 0x02000000;
                break;
            }
            offset = findBytes(fullRam, usbBufferBeginning, offset + usbBufferBeginning.length);
        }
        if (foundRAMBoundsOffset === -1) throw new Error('Cannot find the offset to the reading boundary');

        // Use the offset to rewrite the possible reading boundaries within the RAM.
        await this.factoryIface.changeMemoryState(foundRAMBoundsOffset, 0x10, MemoryType.MAPPED, MemoryOpenType.READ_WRITE);
        await this.factoryIface.write(foundRAMBoundsOffset, new Uint8Array(Array(0x10).fill(0)), MemoryType.MAPPED);

        let firmwareSlices: Uint8Array[] = [];

        // Exploit the now extended boundary to read from 0x0 (flash ROM).
        for (let i = 0; i < romSize; i += 0x10) {
            firmwareSlices.push(await this.factoryIface.read(i, 0x10, MemoryType.MAPPED));
            callback({ type: 'ROM', readBytes: firmwareSlices.length * 0x10, totalBytes: romSize });
        }

        // Close 0x0, as the boundary has been rewritten to that address.
        await this.factoryIface.changeMemoryState(0x0, 0x10, MemoryType.MAPPED, MemoryOpenType.CLOSE);

        return {
            ram: fullRam,
            rom: concatUint8Arrays(firmwareSlices)
        };
    }
}

export function concatUint8Arrays(args: Uint8Array[]) {
    let totalLength = 0;
    for (let a of args) {
        totalLength += a.length;
    }

    let res = new Uint8Array(totalLength);

    let offset = 0;
    for (let a of args) {
        res.set(a, offset);
        offset += a.length;
    }
    return res;
}
