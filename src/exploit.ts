import { NetMDFactoryInterface, NetMDInterface } from 'netmd-js';
import { CORE_MACROS } from './assembler/core-macros';
import { ExploitStateManager } from './exploit-state';
import { getFromVersionStore, getFromVersionStoreOrNull } from './utils';

export class CompatibilityError extends Error {
    constructor(m: string) {
        super(m);
        Object.setPrototypeOf(this, CompatibilityError.prototype);
    }
}

export class PatchError extends Error {
    constructor(m: string) {
        super(m);
        Object.setPrototypeOf(this, PatchError.prototype);
    }
}

export type VersionPropertyStore = {
    [key: string]: { [key: string]: any };
};

export type ExploitConstructor<T extends Exploit> = (new (statemanager: ExploitStateManager) => T) & { _name: string };

export interface ExploitPolicies{
    stateManagerUnpatchLegal?: boolean;
    permanent?: boolean;
};

export class AllocationContext {
    private allocatedAddresses: number[] = [];
    private currentAllocationPtr = 0;
    constructor(private stateManager: ExploitStateManager) { }
    _beginContext() {
        this.currentAllocationPtr = 0;
    }

    public allocate(length: number){
        if(this.currentAllocationPtr >= this.allocatedAddresses.length){
            this.allocatedAddresses.push(this.stateManager.allocate(length));
        }
        return this.allocatedAddresses[this.currentAllocationPtr++];
    }
}

export abstract class Exploit {
    public _policies?: ExploitPolicies;
    protected iface: NetMDInterface;
    protected factoryIface: NetMDFactoryInterface;
    private allocationContext: AllocationContext;
    constructor(protected stateManager: ExploitStateManager) {
        this.iface = stateManager.iface;
        this.factoryIface = stateManager.factoryIface;
        this.allocationContext = new AllocationContext(stateManager);
    }

    async init(...args: any[]) {}
    async unload() {}

    protected abstract getPropertyStore(allocationContext: AllocationContext): VersionPropertyStore;
    private _getPropertyStore(){
        // In order to prevent allocation loops, AllocationContext caches the memory allocation results,
        // and always returns them in the same order they were allocated in (useState-style).
        this.allocationContext._beginContext();
        return this.getPropertyStore(this.allocationContext);
    }

    protected getProperty(name: string): any {
        const store = this._getPropertyStore();
        return getFromVersionStore(store, this.stateManager.device.versionCode, name);
    }

    protected getFirmwareProperty(name: string): any {
        return getFromVersionStore(CORE_MACROS.fw_compat_bridge.properties, this.stateManager.device.versionCode, name);
    }

    protected getPropertyOrNull(name: string): any {
        const store = this._getPropertyStore();
        return getFromVersionStoreOrNull(store, this.stateManager.device.versionCode, name);
    }

    protected getProperties(...names: string[]): any[] {
        return names.map(this.getProperty.bind(this));
    }

    protected assemble(code: string, variables?: { [key: string]: any }): Uint8Array {
        const store = this._getPropertyStore();

        let assemblerUsed;
        if (code.trim().startsWith(';!THUMB')) {
            assemblerUsed = this.stateManager.thumbAssembler;
        } else {
            assemblerUsed = this.stateManager.armAssembler;
        }
        const processedCode = assemblerUsed.processCode(
            code,
            store,
            this.stateManager.device.versionCode,
            variables || {},
            this.getPropertyOrNull('_macros') || {}
        );
        try {
            return assemblerUsed.assemble(assemblerUsed.removeComments(processedCode));
        } catch (error) {
            console.log('Error during the assembly of');
            console.log(processedCode);
            throw error;
        }
    }

    assembleProperty(name: string, variables?: { [key: string]: any }): Uint8Array {
        return this.assemble(this.getProperty(name), variables);
    }
}
